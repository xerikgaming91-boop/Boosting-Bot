
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Raid
 * 
 */
export type Raid = $Result.DefaultSelection<Prisma.$RaidPayload>
/**
 * Model Preset
 * 
 */
export type Preset = $Result.DefaultSelection<Prisma.$PresetPayload>
/**
 * Model BoosterChar
 * 
 */
export type BoosterChar = $Result.DefaultSelection<Prisma.$BoosterCharPayload>
/**
 * Model Signup
 * 
 */
export type Signup = $Result.DefaultSelection<Prisma.$SignupPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const SignupType: {
  TANK: 'TANK',
  HEAL: 'HEAL',
  DPS: 'DPS',
  LOOTBUDDY: 'LOOTBUDDY'
};

export type SignupType = (typeof SignupType)[keyof typeof SignupType]


export const SignupStatus: {
  SIGNUPED: 'SIGNUPED',
  PICKED: 'PICKED'
};

export type SignupStatus = (typeof SignupStatus)[keyof typeof SignupStatus]

}

export type SignupType = $Enums.SignupType

export const SignupType: typeof $Enums.SignupType

export type SignupStatus = $Enums.SignupStatus

export const SignupStatus: typeof $Enums.SignupStatus

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.raid`: Exposes CRUD operations for the **Raid** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Raids
    * const raids = await prisma.raid.findMany()
    * ```
    */
  get raid(): Prisma.RaidDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.preset`: Exposes CRUD operations for the **Preset** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Presets
    * const presets = await prisma.preset.findMany()
    * ```
    */
  get preset(): Prisma.PresetDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.boosterChar`: Exposes CRUD operations for the **BoosterChar** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BoosterChars
    * const boosterChars = await prisma.boosterChar.findMany()
    * ```
    */
  get boosterChar(): Prisma.BoosterCharDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.signup`: Exposes CRUD operations for the **Signup** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Signups
    * const signups = await prisma.signup.findMany()
    * ```
    */
  get signup(): Prisma.SignupDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.16.3
   * Query Engine version: bb420e667c1820a8c05a38023385f6cc7ef8e83a
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Raid: 'Raid',
    Preset: 'Preset',
    BoosterChar: 'BoosterChar',
    Signup: 'Signup'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "raid" | "preset" | "boosterChar" | "signup"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Raid: {
        payload: Prisma.$RaidPayload<ExtArgs>
        fields: Prisma.RaidFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RaidFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RaidPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RaidFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RaidPayload>
          }
          findFirst: {
            args: Prisma.RaidFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RaidPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RaidFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RaidPayload>
          }
          findMany: {
            args: Prisma.RaidFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RaidPayload>[]
          }
          create: {
            args: Prisma.RaidCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RaidPayload>
          }
          createMany: {
            args: Prisma.RaidCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RaidCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RaidPayload>[]
          }
          delete: {
            args: Prisma.RaidDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RaidPayload>
          }
          update: {
            args: Prisma.RaidUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RaidPayload>
          }
          deleteMany: {
            args: Prisma.RaidDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RaidUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RaidUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RaidPayload>[]
          }
          upsert: {
            args: Prisma.RaidUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RaidPayload>
          }
          aggregate: {
            args: Prisma.RaidAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRaid>
          }
          groupBy: {
            args: Prisma.RaidGroupByArgs<ExtArgs>
            result: $Utils.Optional<RaidGroupByOutputType>[]
          }
          count: {
            args: Prisma.RaidCountArgs<ExtArgs>
            result: $Utils.Optional<RaidCountAggregateOutputType> | number
          }
        }
      }
      Preset: {
        payload: Prisma.$PresetPayload<ExtArgs>
        fields: Prisma.PresetFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PresetFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PresetPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PresetFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PresetPayload>
          }
          findFirst: {
            args: Prisma.PresetFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PresetPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PresetFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PresetPayload>
          }
          findMany: {
            args: Prisma.PresetFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PresetPayload>[]
          }
          create: {
            args: Prisma.PresetCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PresetPayload>
          }
          createMany: {
            args: Prisma.PresetCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PresetCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PresetPayload>[]
          }
          delete: {
            args: Prisma.PresetDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PresetPayload>
          }
          update: {
            args: Prisma.PresetUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PresetPayload>
          }
          deleteMany: {
            args: Prisma.PresetDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PresetUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PresetUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PresetPayload>[]
          }
          upsert: {
            args: Prisma.PresetUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PresetPayload>
          }
          aggregate: {
            args: Prisma.PresetAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePreset>
          }
          groupBy: {
            args: Prisma.PresetGroupByArgs<ExtArgs>
            result: $Utils.Optional<PresetGroupByOutputType>[]
          }
          count: {
            args: Prisma.PresetCountArgs<ExtArgs>
            result: $Utils.Optional<PresetCountAggregateOutputType> | number
          }
        }
      }
      BoosterChar: {
        payload: Prisma.$BoosterCharPayload<ExtArgs>
        fields: Prisma.BoosterCharFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BoosterCharFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BoosterCharPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BoosterCharFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BoosterCharPayload>
          }
          findFirst: {
            args: Prisma.BoosterCharFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BoosterCharPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BoosterCharFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BoosterCharPayload>
          }
          findMany: {
            args: Prisma.BoosterCharFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BoosterCharPayload>[]
          }
          create: {
            args: Prisma.BoosterCharCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BoosterCharPayload>
          }
          createMany: {
            args: Prisma.BoosterCharCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BoosterCharCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BoosterCharPayload>[]
          }
          delete: {
            args: Prisma.BoosterCharDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BoosterCharPayload>
          }
          update: {
            args: Prisma.BoosterCharUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BoosterCharPayload>
          }
          deleteMany: {
            args: Prisma.BoosterCharDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BoosterCharUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BoosterCharUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BoosterCharPayload>[]
          }
          upsert: {
            args: Prisma.BoosterCharUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BoosterCharPayload>
          }
          aggregate: {
            args: Prisma.BoosterCharAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBoosterChar>
          }
          groupBy: {
            args: Prisma.BoosterCharGroupByArgs<ExtArgs>
            result: $Utils.Optional<BoosterCharGroupByOutputType>[]
          }
          count: {
            args: Prisma.BoosterCharCountArgs<ExtArgs>
            result: $Utils.Optional<BoosterCharCountAggregateOutputType> | number
          }
        }
      }
      Signup: {
        payload: Prisma.$SignupPayload<ExtArgs>
        fields: Prisma.SignupFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SignupFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SignupPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SignupFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SignupPayload>
          }
          findFirst: {
            args: Prisma.SignupFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SignupPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SignupFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SignupPayload>
          }
          findMany: {
            args: Prisma.SignupFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SignupPayload>[]
          }
          create: {
            args: Prisma.SignupCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SignupPayload>
          }
          createMany: {
            args: Prisma.SignupCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SignupCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SignupPayload>[]
          }
          delete: {
            args: Prisma.SignupDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SignupPayload>
          }
          update: {
            args: Prisma.SignupUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SignupPayload>
          }
          deleteMany: {
            args: Prisma.SignupDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SignupUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SignupUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SignupPayload>[]
          }
          upsert: {
            args: Prisma.SignupUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SignupPayload>
          }
          aggregate: {
            args: Prisma.SignupAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSignup>
          }
          groupBy: {
            args: Prisma.SignupGroupByArgs<ExtArgs>
            result: $Utils.Optional<SignupGroupByOutputType>[]
          }
          count: {
            args: Prisma.SignupCountArgs<ExtArgs>
            result: $Utils.Optional<SignupCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory | null
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    raid?: RaidOmit
    preset?: PresetOmit
    boosterChar?: BoosterCharOmit
    signup?: SignupOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    chars: number
    signups: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chars?: boolean | UserCountOutputTypeCountCharsArgs
    signups?: boolean | UserCountOutputTypeCountSignupsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCharsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BoosterCharWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSignupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SignupWhereInput
  }


  /**
   * Count Type RaidCountOutputType
   */

  export type RaidCountOutputType = {
    signups: number
  }

  export type RaidCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    signups?: boolean | RaidCountOutputTypeCountSignupsArgs
  }

  // Custom InputTypes
  /**
   * RaidCountOutputType without action
   */
  export type RaidCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RaidCountOutputType
     */
    select?: RaidCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RaidCountOutputType without action
   */
  export type RaidCountOutputTypeCountSignupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SignupWhereInput
  }


  /**
   * Count Type PresetCountOutputType
   */

  export type PresetCountOutputType = {
    raids: number
  }

  export type PresetCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    raids?: boolean | PresetCountOutputTypeCountRaidsArgs
  }

  // Custom InputTypes
  /**
   * PresetCountOutputType without action
   */
  export type PresetCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PresetCountOutputType
     */
    select?: PresetCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PresetCountOutputType without action
   */
  export type PresetCountOutputTypeCountRaidsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RaidWhereInput
  }


  /**
   * Count Type BoosterCharCountOutputType
   */

  export type BoosterCharCountOutputType = {
    signups: number
  }

  export type BoosterCharCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    signups?: boolean | BoosterCharCountOutputTypeCountSignupsArgs
  }

  // Custom InputTypes
  /**
   * BoosterCharCountOutputType without action
   */
  export type BoosterCharCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BoosterCharCountOutputType
     */
    select?: BoosterCharCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BoosterCharCountOutputType without action
   */
  export type BoosterCharCountOutputTypeCountSignupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SignupWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
  }

  export type UserSumAggregateOutputType = {
    id: number | null
  }

  export type UserMinAggregateOutputType = {
    id: number | null
    discordId: string | null
    username: string | null
    displayName: string | null
    avatarUrl: string | null
    rolesCsv: string | null
    isRaidlead: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: number | null
    discordId: string | null
    username: string | null
    displayName: string | null
    avatarUrl: string | null
    rolesCsv: string | null
    isRaidlead: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    discordId: number
    username: number
    displayName: number
    avatarUrl: number
    rolesCsv: number
    isRaidlead: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    discordId?: true
    username?: true
    displayName?: true
    avatarUrl?: true
    rolesCsv?: true
    isRaidlead?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    discordId?: true
    username?: true
    displayName?: true
    avatarUrl?: true
    rolesCsv?: true
    isRaidlead?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    discordId?: true
    username?: true
    displayName?: true
    avatarUrl?: true
    rolesCsv?: true
    isRaidlead?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: number
    discordId: string
    username: string | null
    displayName: string | null
    avatarUrl: string | null
    rolesCsv: string | null
    isRaidlead: boolean
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    discordId?: boolean
    username?: boolean
    displayName?: boolean
    avatarUrl?: boolean
    rolesCsv?: boolean
    isRaidlead?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    chars?: boolean | User$charsArgs<ExtArgs>
    signups?: boolean | User$signupsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    discordId?: boolean
    username?: boolean
    displayName?: boolean
    avatarUrl?: boolean
    rolesCsv?: boolean
    isRaidlead?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    discordId?: boolean
    username?: boolean
    displayName?: boolean
    avatarUrl?: boolean
    rolesCsv?: boolean
    isRaidlead?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    discordId?: boolean
    username?: boolean
    displayName?: boolean
    avatarUrl?: boolean
    rolesCsv?: boolean
    isRaidlead?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "discordId" | "username" | "displayName" | "avatarUrl" | "rolesCsv" | "isRaidlead" | "createdAt" | "updatedAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chars?: boolean | User$charsArgs<ExtArgs>
    signups?: boolean | User$signupsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      chars: Prisma.$BoosterCharPayload<ExtArgs>[]
      signups: Prisma.$SignupPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      discordId: string
      username: string | null
      displayName: string | null
      avatarUrl: string | null
      rolesCsv: string | null
      isRaidlead: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    chars<T extends User$charsArgs<ExtArgs> = {}>(args?: Subset<T, User$charsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BoosterCharPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    signups<T extends User$signupsArgs<ExtArgs> = {}>(args?: Subset<T, User$signupsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SignupPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'Int'>
    readonly discordId: FieldRef<"User", 'String'>
    readonly username: FieldRef<"User", 'String'>
    readonly displayName: FieldRef<"User", 'String'>
    readonly avatarUrl: FieldRef<"User", 'String'>
    readonly rolesCsv: FieldRef<"User", 'String'>
    readonly isRaidlead: FieldRef<"User", 'Boolean'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.chars
   */
  export type User$charsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BoosterChar
     */
    select?: BoosterCharSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BoosterChar
     */
    omit?: BoosterCharOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BoosterCharInclude<ExtArgs> | null
    where?: BoosterCharWhereInput
    orderBy?: BoosterCharOrderByWithRelationInput | BoosterCharOrderByWithRelationInput[]
    cursor?: BoosterCharWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BoosterCharScalarFieldEnum | BoosterCharScalarFieldEnum[]
  }

  /**
   * User.signups
   */
  export type User$signupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Signup
     */
    select?: SignupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Signup
     */
    omit?: SignupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SignupInclude<ExtArgs> | null
    where?: SignupWhereInput
    orderBy?: SignupOrderByWithRelationInput | SignupOrderByWithRelationInput[]
    cursor?: SignupWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SignupScalarFieldEnum | SignupScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Raid
   */

  export type AggregateRaid = {
    _count: RaidCountAggregateOutputType | null
    _avg: RaidAvgAggregateOutputType | null
    _sum: RaidSumAggregateOutputType | null
    _min: RaidMinAggregateOutputType | null
    _max: RaidMaxAggregateOutputType | null
  }

  export type RaidAvgAggregateOutputType = {
    id: number | null
    bosses: number | null
    tanks: number | null
    healers: number | null
    dps: number | null
    lootbuddies: number | null
    presetId: number | null
  }

  export type RaidSumAggregateOutputType = {
    id: number | null
    bosses: number | null
    tanks: number | null
    healers: number | null
    dps: number | null
    lootbuddies: number | null
    presetId: number | null
  }

  export type RaidMinAggregateOutputType = {
    id: number | null
    title: string | null
    difficulty: string | null
    lootType: string | null
    date: Date | null
    lead: string | null
    bosses: number | null
    tanks: number | null
    healers: number | null
    dps: number | null
    lootbuddies: number | null
    channelId: string | null
    messageId: string | null
    presetId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RaidMaxAggregateOutputType = {
    id: number | null
    title: string | null
    difficulty: string | null
    lootType: string | null
    date: Date | null
    lead: string | null
    bosses: number | null
    tanks: number | null
    healers: number | null
    dps: number | null
    lootbuddies: number | null
    channelId: string | null
    messageId: string | null
    presetId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RaidCountAggregateOutputType = {
    id: number
    title: number
    difficulty: number
    lootType: number
    date: number
    lead: number
    bosses: number
    tanks: number
    healers: number
    dps: number
    lootbuddies: number
    channelId: number
    messageId: number
    presetId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RaidAvgAggregateInputType = {
    id?: true
    bosses?: true
    tanks?: true
    healers?: true
    dps?: true
    lootbuddies?: true
    presetId?: true
  }

  export type RaidSumAggregateInputType = {
    id?: true
    bosses?: true
    tanks?: true
    healers?: true
    dps?: true
    lootbuddies?: true
    presetId?: true
  }

  export type RaidMinAggregateInputType = {
    id?: true
    title?: true
    difficulty?: true
    lootType?: true
    date?: true
    lead?: true
    bosses?: true
    tanks?: true
    healers?: true
    dps?: true
    lootbuddies?: true
    channelId?: true
    messageId?: true
    presetId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RaidMaxAggregateInputType = {
    id?: true
    title?: true
    difficulty?: true
    lootType?: true
    date?: true
    lead?: true
    bosses?: true
    tanks?: true
    healers?: true
    dps?: true
    lootbuddies?: true
    channelId?: true
    messageId?: true
    presetId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RaidCountAggregateInputType = {
    id?: true
    title?: true
    difficulty?: true
    lootType?: true
    date?: true
    lead?: true
    bosses?: true
    tanks?: true
    healers?: true
    dps?: true
    lootbuddies?: true
    channelId?: true
    messageId?: true
    presetId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RaidAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Raid to aggregate.
     */
    where?: RaidWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Raids to fetch.
     */
    orderBy?: RaidOrderByWithRelationInput | RaidOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RaidWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Raids from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Raids.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Raids
    **/
    _count?: true | RaidCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RaidAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RaidSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RaidMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RaidMaxAggregateInputType
  }

  export type GetRaidAggregateType<T extends RaidAggregateArgs> = {
        [P in keyof T & keyof AggregateRaid]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRaid[P]>
      : GetScalarType<T[P], AggregateRaid[P]>
  }




  export type RaidGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RaidWhereInput
    orderBy?: RaidOrderByWithAggregationInput | RaidOrderByWithAggregationInput[]
    by: RaidScalarFieldEnum[] | RaidScalarFieldEnum
    having?: RaidScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RaidCountAggregateInputType | true
    _avg?: RaidAvgAggregateInputType
    _sum?: RaidSumAggregateInputType
    _min?: RaidMinAggregateInputType
    _max?: RaidMaxAggregateInputType
  }

  export type RaidGroupByOutputType = {
    id: number
    title: string
    difficulty: string
    lootType: string
    date: Date
    lead: string | null
    bosses: number
    tanks: number
    healers: number
    dps: number
    lootbuddies: number
    channelId: string | null
    messageId: string | null
    presetId: number | null
    createdAt: Date
    updatedAt: Date
    _count: RaidCountAggregateOutputType | null
    _avg: RaidAvgAggregateOutputType | null
    _sum: RaidSumAggregateOutputType | null
    _min: RaidMinAggregateOutputType | null
    _max: RaidMaxAggregateOutputType | null
  }

  type GetRaidGroupByPayload<T extends RaidGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RaidGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RaidGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RaidGroupByOutputType[P]>
            : GetScalarType<T[P], RaidGroupByOutputType[P]>
        }
      >
    >


  export type RaidSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    difficulty?: boolean
    lootType?: boolean
    date?: boolean
    lead?: boolean
    bosses?: boolean
    tanks?: boolean
    healers?: boolean
    dps?: boolean
    lootbuddies?: boolean
    channelId?: boolean
    messageId?: boolean
    presetId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    preset?: boolean | Raid$presetArgs<ExtArgs>
    signups?: boolean | Raid$signupsArgs<ExtArgs>
    _count?: boolean | RaidCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["raid"]>

  export type RaidSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    difficulty?: boolean
    lootType?: boolean
    date?: boolean
    lead?: boolean
    bosses?: boolean
    tanks?: boolean
    healers?: boolean
    dps?: boolean
    lootbuddies?: boolean
    channelId?: boolean
    messageId?: boolean
    presetId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    preset?: boolean | Raid$presetArgs<ExtArgs>
  }, ExtArgs["result"]["raid"]>

  export type RaidSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    difficulty?: boolean
    lootType?: boolean
    date?: boolean
    lead?: boolean
    bosses?: boolean
    tanks?: boolean
    healers?: boolean
    dps?: boolean
    lootbuddies?: boolean
    channelId?: boolean
    messageId?: boolean
    presetId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    preset?: boolean | Raid$presetArgs<ExtArgs>
  }, ExtArgs["result"]["raid"]>

  export type RaidSelectScalar = {
    id?: boolean
    title?: boolean
    difficulty?: boolean
    lootType?: boolean
    date?: boolean
    lead?: boolean
    bosses?: boolean
    tanks?: boolean
    healers?: boolean
    dps?: boolean
    lootbuddies?: boolean
    channelId?: boolean
    messageId?: boolean
    presetId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type RaidOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "difficulty" | "lootType" | "date" | "lead" | "bosses" | "tanks" | "healers" | "dps" | "lootbuddies" | "channelId" | "messageId" | "presetId" | "createdAt" | "updatedAt", ExtArgs["result"]["raid"]>
  export type RaidInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    preset?: boolean | Raid$presetArgs<ExtArgs>
    signups?: boolean | Raid$signupsArgs<ExtArgs>
    _count?: boolean | RaidCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RaidIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    preset?: boolean | Raid$presetArgs<ExtArgs>
  }
  export type RaidIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    preset?: boolean | Raid$presetArgs<ExtArgs>
  }

  export type $RaidPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Raid"
    objects: {
      preset: Prisma.$PresetPayload<ExtArgs> | null
      signups: Prisma.$SignupPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      title: string
      difficulty: string
      lootType: string
      date: Date
      lead: string | null
      bosses: number
      tanks: number
      healers: number
      dps: number
      lootbuddies: number
      channelId: string | null
      messageId: string | null
      presetId: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["raid"]>
    composites: {}
  }

  type RaidGetPayload<S extends boolean | null | undefined | RaidDefaultArgs> = $Result.GetResult<Prisma.$RaidPayload, S>

  type RaidCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RaidFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RaidCountAggregateInputType | true
    }

  export interface RaidDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Raid'], meta: { name: 'Raid' } }
    /**
     * Find zero or one Raid that matches the filter.
     * @param {RaidFindUniqueArgs} args - Arguments to find a Raid
     * @example
     * // Get one Raid
     * const raid = await prisma.raid.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RaidFindUniqueArgs>(args: SelectSubset<T, RaidFindUniqueArgs<ExtArgs>>): Prisma__RaidClient<$Result.GetResult<Prisma.$RaidPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Raid that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RaidFindUniqueOrThrowArgs} args - Arguments to find a Raid
     * @example
     * // Get one Raid
     * const raid = await prisma.raid.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RaidFindUniqueOrThrowArgs>(args: SelectSubset<T, RaidFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RaidClient<$Result.GetResult<Prisma.$RaidPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Raid that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RaidFindFirstArgs} args - Arguments to find a Raid
     * @example
     * // Get one Raid
     * const raid = await prisma.raid.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RaidFindFirstArgs>(args?: SelectSubset<T, RaidFindFirstArgs<ExtArgs>>): Prisma__RaidClient<$Result.GetResult<Prisma.$RaidPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Raid that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RaidFindFirstOrThrowArgs} args - Arguments to find a Raid
     * @example
     * // Get one Raid
     * const raid = await prisma.raid.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RaidFindFirstOrThrowArgs>(args?: SelectSubset<T, RaidFindFirstOrThrowArgs<ExtArgs>>): Prisma__RaidClient<$Result.GetResult<Prisma.$RaidPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Raids that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RaidFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Raids
     * const raids = await prisma.raid.findMany()
     * 
     * // Get first 10 Raids
     * const raids = await prisma.raid.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const raidWithIdOnly = await prisma.raid.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RaidFindManyArgs>(args?: SelectSubset<T, RaidFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RaidPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Raid.
     * @param {RaidCreateArgs} args - Arguments to create a Raid.
     * @example
     * // Create one Raid
     * const Raid = await prisma.raid.create({
     *   data: {
     *     // ... data to create a Raid
     *   }
     * })
     * 
     */
    create<T extends RaidCreateArgs>(args: SelectSubset<T, RaidCreateArgs<ExtArgs>>): Prisma__RaidClient<$Result.GetResult<Prisma.$RaidPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Raids.
     * @param {RaidCreateManyArgs} args - Arguments to create many Raids.
     * @example
     * // Create many Raids
     * const raid = await prisma.raid.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RaidCreateManyArgs>(args?: SelectSubset<T, RaidCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Raids and returns the data saved in the database.
     * @param {RaidCreateManyAndReturnArgs} args - Arguments to create many Raids.
     * @example
     * // Create many Raids
     * const raid = await prisma.raid.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Raids and only return the `id`
     * const raidWithIdOnly = await prisma.raid.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RaidCreateManyAndReturnArgs>(args?: SelectSubset<T, RaidCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RaidPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Raid.
     * @param {RaidDeleteArgs} args - Arguments to delete one Raid.
     * @example
     * // Delete one Raid
     * const Raid = await prisma.raid.delete({
     *   where: {
     *     // ... filter to delete one Raid
     *   }
     * })
     * 
     */
    delete<T extends RaidDeleteArgs>(args: SelectSubset<T, RaidDeleteArgs<ExtArgs>>): Prisma__RaidClient<$Result.GetResult<Prisma.$RaidPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Raid.
     * @param {RaidUpdateArgs} args - Arguments to update one Raid.
     * @example
     * // Update one Raid
     * const raid = await prisma.raid.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RaidUpdateArgs>(args: SelectSubset<T, RaidUpdateArgs<ExtArgs>>): Prisma__RaidClient<$Result.GetResult<Prisma.$RaidPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Raids.
     * @param {RaidDeleteManyArgs} args - Arguments to filter Raids to delete.
     * @example
     * // Delete a few Raids
     * const { count } = await prisma.raid.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RaidDeleteManyArgs>(args?: SelectSubset<T, RaidDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Raids.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RaidUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Raids
     * const raid = await prisma.raid.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RaidUpdateManyArgs>(args: SelectSubset<T, RaidUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Raids and returns the data updated in the database.
     * @param {RaidUpdateManyAndReturnArgs} args - Arguments to update many Raids.
     * @example
     * // Update many Raids
     * const raid = await prisma.raid.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Raids and only return the `id`
     * const raidWithIdOnly = await prisma.raid.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RaidUpdateManyAndReturnArgs>(args: SelectSubset<T, RaidUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RaidPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Raid.
     * @param {RaidUpsertArgs} args - Arguments to update or create a Raid.
     * @example
     * // Update or create a Raid
     * const raid = await prisma.raid.upsert({
     *   create: {
     *     // ... data to create a Raid
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Raid we want to update
     *   }
     * })
     */
    upsert<T extends RaidUpsertArgs>(args: SelectSubset<T, RaidUpsertArgs<ExtArgs>>): Prisma__RaidClient<$Result.GetResult<Prisma.$RaidPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Raids.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RaidCountArgs} args - Arguments to filter Raids to count.
     * @example
     * // Count the number of Raids
     * const count = await prisma.raid.count({
     *   where: {
     *     // ... the filter for the Raids we want to count
     *   }
     * })
    **/
    count<T extends RaidCountArgs>(
      args?: Subset<T, RaidCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RaidCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Raid.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RaidAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RaidAggregateArgs>(args: Subset<T, RaidAggregateArgs>): Prisma.PrismaPromise<GetRaidAggregateType<T>>

    /**
     * Group by Raid.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RaidGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RaidGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RaidGroupByArgs['orderBy'] }
        : { orderBy?: RaidGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RaidGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRaidGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Raid model
   */
  readonly fields: RaidFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Raid.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RaidClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    preset<T extends Raid$presetArgs<ExtArgs> = {}>(args?: Subset<T, Raid$presetArgs<ExtArgs>>): Prisma__PresetClient<$Result.GetResult<Prisma.$PresetPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    signups<T extends Raid$signupsArgs<ExtArgs> = {}>(args?: Subset<T, Raid$signupsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SignupPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Raid model
   */
  interface RaidFieldRefs {
    readonly id: FieldRef<"Raid", 'Int'>
    readonly title: FieldRef<"Raid", 'String'>
    readonly difficulty: FieldRef<"Raid", 'String'>
    readonly lootType: FieldRef<"Raid", 'String'>
    readonly date: FieldRef<"Raid", 'DateTime'>
    readonly lead: FieldRef<"Raid", 'String'>
    readonly bosses: FieldRef<"Raid", 'Int'>
    readonly tanks: FieldRef<"Raid", 'Int'>
    readonly healers: FieldRef<"Raid", 'Int'>
    readonly dps: FieldRef<"Raid", 'Int'>
    readonly lootbuddies: FieldRef<"Raid", 'Int'>
    readonly channelId: FieldRef<"Raid", 'String'>
    readonly messageId: FieldRef<"Raid", 'String'>
    readonly presetId: FieldRef<"Raid", 'Int'>
    readonly createdAt: FieldRef<"Raid", 'DateTime'>
    readonly updatedAt: FieldRef<"Raid", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Raid findUnique
   */
  export type RaidFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Raid
     */
    select?: RaidSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Raid
     */
    omit?: RaidOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaidInclude<ExtArgs> | null
    /**
     * Filter, which Raid to fetch.
     */
    where: RaidWhereUniqueInput
  }

  /**
   * Raid findUniqueOrThrow
   */
  export type RaidFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Raid
     */
    select?: RaidSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Raid
     */
    omit?: RaidOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaidInclude<ExtArgs> | null
    /**
     * Filter, which Raid to fetch.
     */
    where: RaidWhereUniqueInput
  }

  /**
   * Raid findFirst
   */
  export type RaidFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Raid
     */
    select?: RaidSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Raid
     */
    omit?: RaidOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaidInclude<ExtArgs> | null
    /**
     * Filter, which Raid to fetch.
     */
    where?: RaidWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Raids to fetch.
     */
    orderBy?: RaidOrderByWithRelationInput | RaidOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Raids.
     */
    cursor?: RaidWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Raids from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Raids.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Raids.
     */
    distinct?: RaidScalarFieldEnum | RaidScalarFieldEnum[]
  }

  /**
   * Raid findFirstOrThrow
   */
  export type RaidFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Raid
     */
    select?: RaidSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Raid
     */
    omit?: RaidOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaidInclude<ExtArgs> | null
    /**
     * Filter, which Raid to fetch.
     */
    where?: RaidWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Raids to fetch.
     */
    orderBy?: RaidOrderByWithRelationInput | RaidOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Raids.
     */
    cursor?: RaidWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Raids from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Raids.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Raids.
     */
    distinct?: RaidScalarFieldEnum | RaidScalarFieldEnum[]
  }

  /**
   * Raid findMany
   */
  export type RaidFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Raid
     */
    select?: RaidSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Raid
     */
    omit?: RaidOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaidInclude<ExtArgs> | null
    /**
     * Filter, which Raids to fetch.
     */
    where?: RaidWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Raids to fetch.
     */
    orderBy?: RaidOrderByWithRelationInput | RaidOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Raids.
     */
    cursor?: RaidWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Raids from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Raids.
     */
    skip?: number
    distinct?: RaidScalarFieldEnum | RaidScalarFieldEnum[]
  }

  /**
   * Raid create
   */
  export type RaidCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Raid
     */
    select?: RaidSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Raid
     */
    omit?: RaidOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaidInclude<ExtArgs> | null
    /**
     * The data needed to create a Raid.
     */
    data: XOR<RaidCreateInput, RaidUncheckedCreateInput>
  }

  /**
   * Raid createMany
   */
  export type RaidCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Raids.
     */
    data: RaidCreateManyInput | RaidCreateManyInput[]
  }

  /**
   * Raid createManyAndReturn
   */
  export type RaidCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Raid
     */
    select?: RaidSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Raid
     */
    omit?: RaidOmit<ExtArgs> | null
    /**
     * The data used to create many Raids.
     */
    data: RaidCreateManyInput | RaidCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaidIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Raid update
   */
  export type RaidUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Raid
     */
    select?: RaidSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Raid
     */
    omit?: RaidOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaidInclude<ExtArgs> | null
    /**
     * The data needed to update a Raid.
     */
    data: XOR<RaidUpdateInput, RaidUncheckedUpdateInput>
    /**
     * Choose, which Raid to update.
     */
    where: RaidWhereUniqueInput
  }

  /**
   * Raid updateMany
   */
  export type RaidUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Raids.
     */
    data: XOR<RaidUpdateManyMutationInput, RaidUncheckedUpdateManyInput>
    /**
     * Filter which Raids to update
     */
    where?: RaidWhereInput
    /**
     * Limit how many Raids to update.
     */
    limit?: number
  }

  /**
   * Raid updateManyAndReturn
   */
  export type RaidUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Raid
     */
    select?: RaidSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Raid
     */
    omit?: RaidOmit<ExtArgs> | null
    /**
     * The data used to update Raids.
     */
    data: XOR<RaidUpdateManyMutationInput, RaidUncheckedUpdateManyInput>
    /**
     * Filter which Raids to update
     */
    where?: RaidWhereInput
    /**
     * Limit how many Raids to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaidIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Raid upsert
   */
  export type RaidUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Raid
     */
    select?: RaidSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Raid
     */
    omit?: RaidOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaidInclude<ExtArgs> | null
    /**
     * The filter to search for the Raid to update in case it exists.
     */
    where: RaidWhereUniqueInput
    /**
     * In case the Raid found by the `where` argument doesn't exist, create a new Raid with this data.
     */
    create: XOR<RaidCreateInput, RaidUncheckedCreateInput>
    /**
     * In case the Raid was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RaidUpdateInput, RaidUncheckedUpdateInput>
  }

  /**
   * Raid delete
   */
  export type RaidDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Raid
     */
    select?: RaidSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Raid
     */
    omit?: RaidOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaidInclude<ExtArgs> | null
    /**
     * Filter which Raid to delete.
     */
    where: RaidWhereUniqueInput
  }

  /**
   * Raid deleteMany
   */
  export type RaidDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Raids to delete
     */
    where?: RaidWhereInput
    /**
     * Limit how many Raids to delete.
     */
    limit?: number
  }

  /**
   * Raid.preset
   */
  export type Raid$presetArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Preset
     */
    select?: PresetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Preset
     */
    omit?: PresetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PresetInclude<ExtArgs> | null
    where?: PresetWhereInput
  }

  /**
   * Raid.signups
   */
  export type Raid$signupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Signup
     */
    select?: SignupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Signup
     */
    omit?: SignupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SignupInclude<ExtArgs> | null
    where?: SignupWhereInput
    orderBy?: SignupOrderByWithRelationInput | SignupOrderByWithRelationInput[]
    cursor?: SignupWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SignupScalarFieldEnum | SignupScalarFieldEnum[]
  }

  /**
   * Raid without action
   */
  export type RaidDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Raid
     */
    select?: RaidSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Raid
     */
    omit?: RaidOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaidInclude<ExtArgs> | null
  }


  /**
   * Model Preset
   */

  export type AggregatePreset = {
    _count: PresetCountAggregateOutputType | null
    _avg: PresetAvgAggregateOutputType | null
    _sum: PresetSumAggregateOutputType | null
    _min: PresetMinAggregateOutputType | null
    _max: PresetMaxAggregateOutputType | null
  }

  export type PresetAvgAggregateOutputType = {
    id: number | null
    tanks: number | null
    healers: number | null
    dps: number | null
    lootbuddies: number | null
  }

  export type PresetSumAggregateOutputType = {
    id: number | null
    tanks: number | null
    healers: number | null
    dps: number | null
    lootbuddies: number | null
  }

  export type PresetMinAggregateOutputType = {
    id: number | null
    name: string | null
    tanks: number | null
    healers: number | null
    dps: number | null
    lootbuddies: number | null
  }

  export type PresetMaxAggregateOutputType = {
    id: number | null
    name: string | null
    tanks: number | null
    healers: number | null
    dps: number | null
    lootbuddies: number | null
  }

  export type PresetCountAggregateOutputType = {
    id: number
    name: number
    tanks: number
    healers: number
    dps: number
    lootbuddies: number
    _all: number
  }


  export type PresetAvgAggregateInputType = {
    id?: true
    tanks?: true
    healers?: true
    dps?: true
    lootbuddies?: true
  }

  export type PresetSumAggregateInputType = {
    id?: true
    tanks?: true
    healers?: true
    dps?: true
    lootbuddies?: true
  }

  export type PresetMinAggregateInputType = {
    id?: true
    name?: true
    tanks?: true
    healers?: true
    dps?: true
    lootbuddies?: true
  }

  export type PresetMaxAggregateInputType = {
    id?: true
    name?: true
    tanks?: true
    healers?: true
    dps?: true
    lootbuddies?: true
  }

  export type PresetCountAggregateInputType = {
    id?: true
    name?: true
    tanks?: true
    healers?: true
    dps?: true
    lootbuddies?: true
    _all?: true
  }

  export type PresetAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Preset to aggregate.
     */
    where?: PresetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Presets to fetch.
     */
    orderBy?: PresetOrderByWithRelationInput | PresetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PresetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Presets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Presets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Presets
    **/
    _count?: true | PresetCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PresetAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PresetSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PresetMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PresetMaxAggregateInputType
  }

  export type GetPresetAggregateType<T extends PresetAggregateArgs> = {
        [P in keyof T & keyof AggregatePreset]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePreset[P]>
      : GetScalarType<T[P], AggregatePreset[P]>
  }




  export type PresetGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PresetWhereInput
    orderBy?: PresetOrderByWithAggregationInput | PresetOrderByWithAggregationInput[]
    by: PresetScalarFieldEnum[] | PresetScalarFieldEnum
    having?: PresetScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PresetCountAggregateInputType | true
    _avg?: PresetAvgAggregateInputType
    _sum?: PresetSumAggregateInputType
    _min?: PresetMinAggregateInputType
    _max?: PresetMaxAggregateInputType
  }

  export type PresetGroupByOutputType = {
    id: number
    name: string
    tanks: number
    healers: number
    dps: number
    lootbuddies: number
    _count: PresetCountAggregateOutputType | null
    _avg: PresetAvgAggregateOutputType | null
    _sum: PresetSumAggregateOutputType | null
    _min: PresetMinAggregateOutputType | null
    _max: PresetMaxAggregateOutputType | null
  }

  type GetPresetGroupByPayload<T extends PresetGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PresetGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PresetGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PresetGroupByOutputType[P]>
            : GetScalarType<T[P], PresetGroupByOutputType[P]>
        }
      >
    >


  export type PresetSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    tanks?: boolean
    healers?: boolean
    dps?: boolean
    lootbuddies?: boolean
    raids?: boolean | Preset$raidsArgs<ExtArgs>
    _count?: boolean | PresetCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["preset"]>

  export type PresetSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    tanks?: boolean
    healers?: boolean
    dps?: boolean
    lootbuddies?: boolean
  }, ExtArgs["result"]["preset"]>

  export type PresetSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    tanks?: boolean
    healers?: boolean
    dps?: boolean
    lootbuddies?: boolean
  }, ExtArgs["result"]["preset"]>

  export type PresetSelectScalar = {
    id?: boolean
    name?: boolean
    tanks?: boolean
    healers?: boolean
    dps?: boolean
    lootbuddies?: boolean
  }

  export type PresetOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "tanks" | "healers" | "dps" | "lootbuddies", ExtArgs["result"]["preset"]>
  export type PresetInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    raids?: boolean | Preset$raidsArgs<ExtArgs>
    _count?: boolean | PresetCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PresetIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type PresetIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $PresetPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Preset"
    objects: {
      raids: Prisma.$RaidPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      tanks: number
      healers: number
      dps: number
      lootbuddies: number
    }, ExtArgs["result"]["preset"]>
    composites: {}
  }

  type PresetGetPayload<S extends boolean | null | undefined | PresetDefaultArgs> = $Result.GetResult<Prisma.$PresetPayload, S>

  type PresetCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PresetFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PresetCountAggregateInputType | true
    }

  export interface PresetDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Preset'], meta: { name: 'Preset' } }
    /**
     * Find zero or one Preset that matches the filter.
     * @param {PresetFindUniqueArgs} args - Arguments to find a Preset
     * @example
     * // Get one Preset
     * const preset = await prisma.preset.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PresetFindUniqueArgs>(args: SelectSubset<T, PresetFindUniqueArgs<ExtArgs>>): Prisma__PresetClient<$Result.GetResult<Prisma.$PresetPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Preset that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PresetFindUniqueOrThrowArgs} args - Arguments to find a Preset
     * @example
     * // Get one Preset
     * const preset = await prisma.preset.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PresetFindUniqueOrThrowArgs>(args: SelectSubset<T, PresetFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PresetClient<$Result.GetResult<Prisma.$PresetPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Preset that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PresetFindFirstArgs} args - Arguments to find a Preset
     * @example
     * // Get one Preset
     * const preset = await prisma.preset.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PresetFindFirstArgs>(args?: SelectSubset<T, PresetFindFirstArgs<ExtArgs>>): Prisma__PresetClient<$Result.GetResult<Prisma.$PresetPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Preset that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PresetFindFirstOrThrowArgs} args - Arguments to find a Preset
     * @example
     * // Get one Preset
     * const preset = await prisma.preset.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PresetFindFirstOrThrowArgs>(args?: SelectSubset<T, PresetFindFirstOrThrowArgs<ExtArgs>>): Prisma__PresetClient<$Result.GetResult<Prisma.$PresetPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Presets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PresetFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Presets
     * const presets = await prisma.preset.findMany()
     * 
     * // Get first 10 Presets
     * const presets = await prisma.preset.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const presetWithIdOnly = await prisma.preset.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PresetFindManyArgs>(args?: SelectSubset<T, PresetFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PresetPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Preset.
     * @param {PresetCreateArgs} args - Arguments to create a Preset.
     * @example
     * // Create one Preset
     * const Preset = await prisma.preset.create({
     *   data: {
     *     // ... data to create a Preset
     *   }
     * })
     * 
     */
    create<T extends PresetCreateArgs>(args: SelectSubset<T, PresetCreateArgs<ExtArgs>>): Prisma__PresetClient<$Result.GetResult<Prisma.$PresetPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Presets.
     * @param {PresetCreateManyArgs} args - Arguments to create many Presets.
     * @example
     * // Create many Presets
     * const preset = await prisma.preset.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PresetCreateManyArgs>(args?: SelectSubset<T, PresetCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Presets and returns the data saved in the database.
     * @param {PresetCreateManyAndReturnArgs} args - Arguments to create many Presets.
     * @example
     * // Create many Presets
     * const preset = await prisma.preset.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Presets and only return the `id`
     * const presetWithIdOnly = await prisma.preset.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PresetCreateManyAndReturnArgs>(args?: SelectSubset<T, PresetCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PresetPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Preset.
     * @param {PresetDeleteArgs} args - Arguments to delete one Preset.
     * @example
     * // Delete one Preset
     * const Preset = await prisma.preset.delete({
     *   where: {
     *     // ... filter to delete one Preset
     *   }
     * })
     * 
     */
    delete<T extends PresetDeleteArgs>(args: SelectSubset<T, PresetDeleteArgs<ExtArgs>>): Prisma__PresetClient<$Result.GetResult<Prisma.$PresetPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Preset.
     * @param {PresetUpdateArgs} args - Arguments to update one Preset.
     * @example
     * // Update one Preset
     * const preset = await prisma.preset.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PresetUpdateArgs>(args: SelectSubset<T, PresetUpdateArgs<ExtArgs>>): Prisma__PresetClient<$Result.GetResult<Prisma.$PresetPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Presets.
     * @param {PresetDeleteManyArgs} args - Arguments to filter Presets to delete.
     * @example
     * // Delete a few Presets
     * const { count } = await prisma.preset.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PresetDeleteManyArgs>(args?: SelectSubset<T, PresetDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Presets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PresetUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Presets
     * const preset = await prisma.preset.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PresetUpdateManyArgs>(args: SelectSubset<T, PresetUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Presets and returns the data updated in the database.
     * @param {PresetUpdateManyAndReturnArgs} args - Arguments to update many Presets.
     * @example
     * // Update many Presets
     * const preset = await prisma.preset.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Presets and only return the `id`
     * const presetWithIdOnly = await prisma.preset.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PresetUpdateManyAndReturnArgs>(args: SelectSubset<T, PresetUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PresetPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Preset.
     * @param {PresetUpsertArgs} args - Arguments to update or create a Preset.
     * @example
     * // Update or create a Preset
     * const preset = await prisma.preset.upsert({
     *   create: {
     *     // ... data to create a Preset
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Preset we want to update
     *   }
     * })
     */
    upsert<T extends PresetUpsertArgs>(args: SelectSubset<T, PresetUpsertArgs<ExtArgs>>): Prisma__PresetClient<$Result.GetResult<Prisma.$PresetPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Presets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PresetCountArgs} args - Arguments to filter Presets to count.
     * @example
     * // Count the number of Presets
     * const count = await prisma.preset.count({
     *   where: {
     *     // ... the filter for the Presets we want to count
     *   }
     * })
    **/
    count<T extends PresetCountArgs>(
      args?: Subset<T, PresetCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PresetCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Preset.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PresetAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PresetAggregateArgs>(args: Subset<T, PresetAggregateArgs>): Prisma.PrismaPromise<GetPresetAggregateType<T>>

    /**
     * Group by Preset.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PresetGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PresetGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PresetGroupByArgs['orderBy'] }
        : { orderBy?: PresetGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PresetGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPresetGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Preset model
   */
  readonly fields: PresetFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Preset.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PresetClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    raids<T extends Preset$raidsArgs<ExtArgs> = {}>(args?: Subset<T, Preset$raidsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RaidPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Preset model
   */
  interface PresetFieldRefs {
    readonly id: FieldRef<"Preset", 'Int'>
    readonly name: FieldRef<"Preset", 'String'>
    readonly tanks: FieldRef<"Preset", 'Int'>
    readonly healers: FieldRef<"Preset", 'Int'>
    readonly dps: FieldRef<"Preset", 'Int'>
    readonly lootbuddies: FieldRef<"Preset", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Preset findUnique
   */
  export type PresetFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Preset
     */
    select?: PresetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Preset
     */
    omit?: PresetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PresetInclude<ExtArgs> | null
    /**
     * Filter, which Preset to fetch.
     */
    where: PresetWhereUniqueInput
  }

  /**
   * Preset findUniqueOrThrow
   */
  export type PresetFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Preset
     */
    select?: PresetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Preset
     */
    omit?: PresetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PresetInclude<ExtArgs> | null
    /**
     * Filter, which Preset to fetch.
     */
    where: PresetWhereUniqueInput
  }

  /**
   * Preset findFirst
   */
  export type PresetFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Preset
     */
    select?: PresetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Preset
     */
    omit?: PresetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PresetInclude<ExtArgs> | null
    /**
     * Filter, which Preset to fetch.
     */
    where?: PresetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Presets to fetch.
     */
    orderBy?: PresetOrderByWithRelationInput | PresetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Presets.
     */
    cursor?: PresetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Presets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Presets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Presets.
     */
    distinct?: PresetScalarFieldEnum | PresetScalarFieldEnum[]
  }

  /**
   * Preset findFirstOrThrow
   */
  export type PresetFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Preset
     */
    select?: PresetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Preset
     */
    omit?: PresetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PresetInclude<ExtArgs> | null
    /**
     * Filter, which Preset to fetch.
     */
    where?: PresetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Presets to fetch.
     */
    orderBy?: PresetOrderByWithRelationInput | PresetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Presets.
     */
    cursor?: PresetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Presets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Presets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Presets.
     */
    distinct?: PresetScalarFieldEnum | PresetScalarFieldEnum[]
  }

  /**
   * Preset findMany
   */
  export type PresetFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Preset
     */
    select?: PresetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Preset
     */
    omit?: PresetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PresetInclude<ExtArgs> | null
    /**
     * Filter, which Presets to fetch.
     */
    where?: PresetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Presets to fetch.
     */
    orderBy?: PresetOrderByWithRelationInput | PresetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Presets.
     */
    cursor?: PresetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Presets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Presets.
     */
    skip?: number
    distinct?: PresetScalarFieldEnum | PresetScalarFieldEnum[]
  }

  /**
   * Preset create
   */
  export type PresetCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Preset
     */
    select?: PresetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Preset
     */
    omit?: PresetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PresetInclude<ExtArgs> | null
    /**
     * The data needed to create a Preset.
     */
    data: XOR<PresetCreateInput, PresetUncheckedCreateInput>
  }

  /**
   * Preset createMany
   */
  export type PresetCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Presets.
     */
    data: PresetCreateManyInput | PresetCreateManyInput[]
  }

  /**
   * Preset createManyAndReturn
   */
  export type PresetCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Preset
     */
    select?: PresetSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Preset
     */
    omit?: PresetOmit<ExtArgs> | null
    /**
     * The data used to create many Presets.
     */
    data: PresetCreateManyInput | PresetCreateManyInput[]
  }

  /**
   * Preset update
   */
  export type PresetUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Preset
     */
    select?: PresetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Preset
     */
    omit?: PresetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PresetInclude<ExtArgs> | null
    /**
     * The data needed to update a Preset.
     */
    data: XOR<PresetUpdateInput, PresetUncheckedUpdateInput>
    /**
     * Choose, which Preset to update.
     */
    where: PresetWhereUniqueInput
  }

  /**
   * Preset updateMany
   */
  export type PresetUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Presets.
     */
    data: XOR<PresetUpdateManyMutationInput, PresetUncheckedUpdateManyInput>
    /**
     * Filter which Presets to update
     */
    where?: PresetWhereInput
    /**
     * Limit how many Presets to update.
     */
    limit?: number
  }

  /**
   * Preset updateManyAndReturn
   */
  export type PresetUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Preset
     */
    select?: PresetSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Preset
     */
    omit?: PresetOmit<ExtArgs> | null
    /**
     * The data used to update Presets.
     */
    data: XOR<PresetUpdateManyMutationInput, PresetUncheckedUpdateManyInput>
    /**
     * Filter which Presets to update
     */
    where?: PresetWhereInput
    /**
     * Limit how many Presets to update.
     */
    limit?: number
  }

  /**
   * Preset upsert
   */
  export type PresetUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Preset
     */
    select?: PresetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Preset
     */
    omit?: PresetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PresetInclude<ExtArgs> | null
    /**
     * The filter to search for the Preset to update in case it exists.
     */
    where: PresetWhereUniqueInput
    /**
     * In case the Preset found by the `where` argument doesn't exist, create a new Preset with this data.
     */
    create: XOR<PresetCreateInput, PresetUncheckedCreateInput>
    /**
     * In case the Preset was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PresetUpdateInput, PresetUncheckedUpdateInput>
  }

  /**
   * Preset delete
   */
  export type PresetDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Preset
     */
    select?: PresetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Preset
     */
    omit?: PresetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PresetInclude<ExtArgs> | null
    /**
     * Filter which Preset to delete.
     */
    where: PresetWhereUniqueInput
  }

  /**
   * Preset deleteMany
   */
  export type PresetDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Presets to delete
     */
    where?: PresetWhereInput
    /**
     * Limit how many Presets to delete.
     */
    limit?: number
  }

  /**
   * Preset.raids
   */
  export type Preset$raidsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Raid
     */
    select?: RaidSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Raid
     */
    omit?: RaidOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaidInclude<ExtArgs> | null
    where?: RaidWhereInput
    orderBy?: RaidOrderByWithRelationInput | RaidOrderByWithRelationInput[]
    cursor?: RaidWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RaidScalarFieldEnum | RaidScalarFieldEnum[]
  }

  /**
   * Preset without action
   */
  export type PresetDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Preset
     */
    select?: PresetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Preset
     */
    omit?: PresetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PresetInclude<ExtArgs> | null
  }


  /**
   * Model BoosterChar
   */

  export type AggregateBoosterChar = {
    _count: BoosterCharCountAggregateOutputType | null
    _avg: BoosterCharAvgAggregateOutputType | null
    _sum: BoosterCharSumAggregateOutputType | null
    _min: BoosterCharMinAggregateOutputType | null
    _max: BoosterCharMaxAggregateOutputType | null
  }

  export type BoosterCharAvgAggregateOutputType = {
    id: number | null
    rioScore: number | null
    itemLevel: number | null
  }

  export type BoosterCharSumAggregateOutputType = {
    id: number | null
    rioScore: number | null
    itemLevel: number | null
  }

  export type BoosterCharMinAggregateOutputType = {
    id: number | null
    userId: string | null
    name: string | null
    realm: string | null
    class: string | null
    spec: string | null
    rioScore: number | null
    progress: string | null
    itemLevel: number | null
    wclUrl: string | null
    updatedAt: Date | null
  }

  export type BoosterCharMaxAggregateOutputType = {
    id: number | null
    userId: string | null
    name: string | null
    realm: string | null
    class: string | null
    spec: string | null
    rioScore: number | null
    progress: string | null
    itemLevel: number | null
    wclUrl: string | null
    updatedAt: Date | null
  }

  export type BoosterCharCountAggregateOutputType = {
    id: number
    userId: number
    name: number
    realm: number
    class: number
    spec: number
    rioScore: number
    progress: number
    itemLevel: number
    wclUrl: number
    updatedAt: number
    _all: number
  }


  export type BoosterCharAvgAggregateInputType = {
    id?: true
    rioScore?: true
    itemLevel?: true
  }

  export type BoosterCharSumAggregateInputType = {
    id?: true
    rioScore?: true
    itemLevel?: true
  }

  export type BoosterCharMinAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    realm?: true
    class?: true
    spec?: true
    rioScore?: true
    progress?: true
    itemLevel?: true
    wclUrl?: true
    updatedAt?: true
  }

  export type BoosterCharMaxAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    realm?: true
    class?: true
    spec?: true
    rioScore?: true
    progress?: true
    itemLevel?: true
    wclUrl?: true
    updatedAt?: true
  }

  export type BoosterCharCountAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    realm?: true
    class?: true
    spec?: true
    rioScore?: true
    progress?: true
    itemLevel?: true
    wclUrl?: true
    updatedAt?: true
    _all?: true
  }

  export type BoosterCharAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BoosterChar to aggregate.
     */
    where?: BoosterCharWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BoosterChars to fetch.
     */
    orderBy?: BoosterCharOrderByWithRelationInput | BoosterCharOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BoosterCharWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BoosterChars from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BoosterChars.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BoosterChars
    **/
    _count?: true | BoosterCharCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BoosterCharAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BoosterCharSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BoosterCharMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BoosterCharMaxAggregateInputType
  }

  export type GetBoosterCharAggregateType<T extends BoosterCharAggregateArgs> = {
        [P in keyof T & keyof AggregateBoosterChar]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBoosterChar[P]>
      : GetScalarType<T[P], AggregateBoosterChar[P]>
  }




  export type BoosterCharGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BoosterCharWhereInput
    orderBy?: BoosterCharOrderByWithAggregationInput | BoosterCharOrderByWithAggregationInput[]
    by: BoosterCharScalarFieldEnum[] | BoosterCharScalarFieldEnum
    having?: BoosterCharScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BoosterCharCountAggregateInputType | true
    _avg?: BoosterCharAvgAggregateInputType
    _sum?: BoosterCharSumAggregateInputType
    _min?: BoosterCharMinAggregateInputType
    _max?: BoosterCharMaxAggregateInputType
  }

  export type BoosterCharGroupByOutputType = {
    id: number
    userId: string
    name: string
    realm: string
    class: string | null
    spec: string | null
    rioScore: number | null
    progress: string | null
    itemLevel: number | null
    wclUrl: string | null
    updatedAt: Date
    _count: BoosterCharCountAggregateOutputType | null
    _avg: BoosterCharAvgAggregateOutputType | null
    _sum: BoosterCharSumAggregateOutputType | null
    _min: BoosterCharMinAggregateOutputType | null
    _max: BoosterCharMaxAggregateOutputType | null
  }

  type GetBoosterCharGroupByPayload<T extends BoosterCharGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BoosterCharGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BoosterCharGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BoosterCharGroupByOutputType[P]>
            : GetScalarType<T[P], BoosterCharGroupByOutputType[P]>
        }
      >
    >


  export type BoosterCharSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    realm?: boolean
    class?: boolean
    spec?: boolean
    rioScore?: boolean
    progress?: boolean
    itemLevel?: boolean
    wclUrl?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    signups?: boolean | BoosterChar$signupsArgs<ExtArgs>
    _count?: boolean | BoosterCharCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["boosterChar"]>

  export type BoosterCharSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    realm?: boolean
    class?: boolean
    spec?: boolean
    rioScore?: boolean
    progress?: boolean
    itemLevel?: boolean
    wclUrl?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["boosterChar"]>

  export type BoosterCharSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    realm?: boolean
    class?: boolean
    spec?: boolean
    rioScore?: boolean
    progress?: boolean
    itemLevel?: boolean
    wclUrl?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["boosterChar"]>

  export type BoosterCharSelectScalar = {
    id?: boolean
    userId?: boolean
    name?: boolean
    realm?: boolean
    class?: boolean
    spec?: boolean
    rioScore?: boolean
    progress?: boolean
    itemLevel?: boolean
    wclUrl?: boolean
    updatedAt?: boolean
  }

  export type BoosterCharOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "name" | "realm" | "class" | "spec" | "rioScore" | "progress" | "itemLevel" | "wclUrl" | "updatedAt", ExtArgs["result"]["boosterChar"]>
  export type BoosterCharInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    signups?: boolean | BoosterChar$signupsArgs<ExtArgs>
    _count?: boolean | BoosterCharCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BoosterCharIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type BoosterCharIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $BoosterCharPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BoosterChar"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      signups: Prisma.$SignupPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: string
      name: string
      realm: string
      class: string | null
      spec: string | null
      rioScore: number | null
      progress: string | null
      itemLevel: number | null
      wclUrl: string | null
      updatedAt: Date
    }, ExtArgs["result"]["boosterChar"]>
    composites: {}
  }

  type BoosterCharGetPayload<S extends boolean | null | undefined | BoosterCharDefaultArgs> = $Result.GetResult<Prisma.$BoosterCharPayload, S>

  type BoosterCharCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BoosterCharFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BoosterCharCountAggregateInputType | true
    }

  export interface BoosterCharDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BoosterChar'], meta: { name: 'BoosterChar' } }
    /**
     * Find zero or one BoosterChar that matches the filter.
     * @param {BoosterCharFindUniqueArgs} args - Arguments to find a BoosterChar
     * @example
     * // Get one BoosterChar
     * const boosterChar = await prisma.boosterChar.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BoosterCharFindUniqueArgs>(args: SelectSubset<T, BoosterCharFindUniqueArgs<ExtArgs>>): Prisma__BoosterCharClient<$Result.GetResult<Prisma.$BoosterCharPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BoosterChar that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BoosterCharFindUniqueOrThrowArgs} args - Arguments to find a BoosterChar
     * @example
     * // Get one BoosterChar
     * const boosterChar = await prisma.boosterChar.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BoosterCharFindUniqueOrThrowArgs>(args: SelectSubset<T, BoosterCharFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BoosterCharClient<$Result.GetResult<Prisma.$BoosterCharPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BoosterChar that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoosterCharFindFirstArgs} args - Arguments to find a BoosterChar
     * @example
     * // Get one BoosterChar
     * const boosterChar = await prisma.boosterChar.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BoosterCharFindFirstArgs>(args?: SelectSubset<T, BoosterCharFindFirstArgs<ExtArgs>>): Prisma__BoosterCharClient<$Result.GetResult<Prisma.$BoosterCharPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BoosterChar that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoosterCharFindFirstOrThrowArgs} args - Arguments to find a BoosterChar
     * @example
     * // Get one BoosterChar
     * const boosterChar = await prisma.boosterChar.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BoosterCharFindFirstOrThrowArgs>(args?: SelectSubset<T, BoosterCharFindFirstOrThrowArgs<ExtArgs>>): Prisma__BoosterCharClient<$Result.GetResult<Prisma.$BoosterCharPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BoosterChars that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoosterCharFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BoosterChars
     * const boosterChars = await prisma.boosterChar.findMany()
     * 
     * // Get first 10 BoosterChars
     * const boosterChars = await prisma.boosterChar.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const boosterCharWithIdOnly = await prisma.boosterChar.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BoosterCharFindManyArgs>(args?: SelectSubset<T, BoosterCharFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BoosterCharPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BoosterChar.
     * @param {BoosterCharCreateArgs} args - Arguments to create a BoosterChar.
     * @example
     * // Create one BoosterChar
     * const BoosterChar = await prisma.boosterChar.create({
     *   data: {
     *     // ... data to create a BoosterChar
     *   }
     * })
     * 
     */
    create<T extends BoosterCharCreateArgs>(args: SelectSubset<T, BoosterCharCreateArgs<ExtArgs>>): Prisma__BoosterCharClient<$Result.GetResult<Prisma.$BoosterCharPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BoosterChars.
     * @param {BoosterCharCreateManyArgs} args - Arguments to create many BoosterChars.
     * @example
     * // Create many BoosterChars
     * const boosterChar = await prisma.boosterChar.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BoosterCharCreateManyArgs>(args?: SelectSubset<T, BoosterCharCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BoosterChars and returns the data saved in the database.
     * @param {BoosterCharCreateManyAndReturnArgs} args - Arguments to create many BoosterChars.
     * @example
     * // Create many BoosterChars
     * const boosterChar = await prisma.boosterChar.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BoosterChars and only return the `id`
     * const boosterCharWithIdOnly = await prisma.boosterChar.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BoosterCharCreateManyAndReturnArgs>(args?: SelectSubset<T, BoosterCharCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BoosterCharPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BoosterChar.
     * @param {BoosterCharDeleteArgs} args - Arguments to delete one BoosterChar.
     * @example
     * // Delete one BoosterChar
     * const BoosterChar = await prisma.boosterChar.delete({
     *   where: {
     *     // ... filter to delete one BoosterChar
     *   }
     * })
     * 
     */
    delete<T extends BoosterCharDeleteArgs>(args: SelectSubset<T, BoosterCharDeleteArgs<ExtArgs>>): Prisma__BoosterCharClient<$Result.GetResult<Prisma.$BoosterCharPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BoosterChar.
     * @param {BoosterCharUpdateArgs} args - Arguments to update one BoosterChar.
     * @example
     * // Update one BoosterChar
     * const boosterChar = await prisma.boosterChar.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BoosterCharUpdateArgs>(args: SelectSubset<T, BoosterCharUpdateArgs<ExtArgs>>): Prisma__BoosterCharClient<$Result.GetResult<Prisma.$BoosterCharPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BoosterChars.
     * @param {BoosterCharDeleteManyArgs} args - Arguments to filter BoosterChars to delete.
     * @example
     * // Delete a few BoosterChars
     * const { count } = await prisma.boosterChar.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BoosterCharDeleteManyArgs>(args?: SelectSubset<T, BoosterCharDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BoosterChars.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoosterCharUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BoosterChars
     * const boosterChar = await prisma.boosterChar.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BoosterCharUpdateManyArgs>(args: SelectSubset<T, BoosterCharUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BoosterChars and returns the data updated in the database.
     * @param {BoosterCharUpdateManyAndReturnArgs} args - Arguments to update many BoosterChars.
     * @example
     * // Update many BoosterChars
     * const boosterChar = await prisma.boosterChar.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BoosterChars and only return the `id`
     * const boosterCharWithIdOnly = await prisma.boosterChar.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BoosterCharUpdateManyAndReturnArgs>(args: SelectSubset<T, BoosterCharUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BoosterCharPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BoosterChar.
     * @param {BoosterCharUpsertArgs} args - Arguments to update or create a BoosterChar.
     * @example
     * // Update or create a BoosterChar
     * const boosterChar = await prisma.boosterChar.upsert({
     *   create: {
     *     // ... data to create a BoosterChar
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BoosterChar we want to update
     *   }
     * })
     */
    upsert<T extends BoosterCharUpsertArgs>(args: SelectSubset<T, BoosterCharUpsertArgs<ExtArgs>>): Prisma__BoosterCharClient<$Result.GetResult<Prisma.$BoosterCharPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BoosterChars.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoosterCharCountArgs} args - Arguments to filter BoosterChars to count.
     * @example
     * // Count the number of BoosterChars
     * const count = await prisma.boosterChar.count({
     *   where: {
     *     // ... the filter for the BoosterChars we want to count
     *   }
     * })
    **/
    count<T extends BoosterCharCountArgs>(
      args?: Subset<T, BoosterCharCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BoosterCharCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BoosterChar.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoosterCharAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BoosterCharAggregateArgs>(args: Subset<T, BoosterCharAggregateArgs>): Prisma.PrismaPromise<GetBoosterCharAggregateType<T>>

    /**
     * Group by BoosterChar.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoosterCharGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BoosterCharGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BoosterCharGroupByArgs['orderBy'] }
        : { orderBy?: BoosterCharGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BoosterCharGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBoosterCharGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BoosterChar model
   */
  readonly fields: BoosterCharFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BoosterChar.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BoosterCharClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    signups<T extends BoosterChar$signupsArgs<ExtArgs> = {}>(args?: Subset<T, BoosterChar$signupsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SignupPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BoosterChar model
   */
  interface BoosterCharFieldRefs {
    readonly id: FieldRef<"BoosterChar", 'Int'>
    readonly userId: FieldRef<"BoosterChar", 'String'>
    readonly name: FieldRef<"BoosterChar", 'String'>
    readonly realm: FieldRef<"BoosterChar", 'String'>
    readonly class: FieldRef<"BoosterChar", 'String'>
    readonly spec: FieldRef<"BoosterChar", 'String'>
    readonly rioScore: FieldRef<"BoosterChar", 'Float'>
    readonly progress: FieldRef<"BoosterChar", 'String'>
    readonly itemLevel: FieldRef<"BoosterChar", 'Int'>
    readonly wclUrl: FieldRef<"BoosterChar", 'String'>
    readonly updatedAt: FieldRef<"BoosterChar", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BoosterChar findUnique
   */
  export type BoosterCharFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BoosterChar
     */
    select?: BoosterCharSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BoosterChar
     */
    omit?: BoosterCharOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BoosterCharInclude<ExtArgs> | null
    /**
     * Filter, which BoosterChar to fetch.
     */
    where: BoosterCharWhereUniqueInput
  }

  /**
   * BoosterChar findUniqueOrThrow
   */
  export type BoosterCharFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BoosterChar
     */
    select?: BoosterCharSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BoosterChar
     */
    omit?: BoosterCharOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BoosterCharInclude<ExtArgs> | null
    /**
     * Filter, which BoosterChar to fetch.
     */
    where: BoosterCharWhereUniqueInput
  }

  /**
   * BoosterChar findFirst
   */
  export type BoosterCharFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BoosterChar
     */
    select?: BoosterCharSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BoosterChar
     */
    omit?: BoosterCharOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BoosterCharInclude<ExtArgs> | null
    /**
     * Filter, which BoosterChar to fetch.
     */
    where?: BoosterCharWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BoosterChars to fetch.
     */
    orderBy?: BoosterCharOrderByWithRelationInput | BoosterCharOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BoosterChars.
     */
    cursor?: BoosterCharWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BoosterChars from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BoosterChars.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BoosterChars.
     */
    distinct?: BoosterCharScalarFieldEnum | BoosterCharScalarFieldEnum[]
  }

  /**
   * BoosterChar findFirstOrThrow
   */
  export type BoosterCharFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BoosterChar
     */
    select?: BoosterCharSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BoosterChar
     */
    omit?: BoosterCharOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BoosterCharInclude<ExtArgs> | null
    /**
     * Filter, which BoosterChar to fetch.
     */
    where?: BoosterCharWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BoosterChars to fetch.
     */
    orderBy?: BoosterCharOrderByWithRelationInput | BoosterCharOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BoosterChars.
     */
    cursor?: BoosterCharWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BoosterChars from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BoosterChars.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BoosterChars.
     */
    distinct?: BoosterCharScalarFieldEnum | BoosterCharScalarFieldEnum[]
  }

  /**
   * BoosterChar findMany
   */
  export type BoosterCharFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BoosterChar
     */
    select?: BoosterCharSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BoosterChar
     */
    omit?: BoosterCharOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BoosterCharInclude<ExtArgs> | null
    /**
     * Filter, which BoosterChars to fetch.
     */
    where?: BoosterCharWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BoosterChars to fetch.
     */
    orderBy?: BoosterCharOrderByWithRelationInput | BoosterCharOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BoosterChars.
     */
    cursor?: BoosterCharWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BoosterChars from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BoosterChars.
     */
    skip?: number
    distinct?: BoosterCharScalarFieldEnum | BoosterCharScalarFieldEnum[]
  }

  /**
   * BoosterChar create
   */
  export type BoosterCharCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BoosterChar
     */
    select?: BoosterCharSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BoosterChar
     */
    omit?: BoosterCharOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BoosterCharInclude<ExtArgs> | null
    /**
     * The data needed to create a BoosterChar.
     */
    data: XOR<BoosterCharCreateInput, BoosterCharUncheckedCreateInput>
  }

  /**
   * BoosterChar createMany
   */
  export type BoosterCharCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BoosterChars.
     */
    data: BoosterCharCreateManyInput | BoosterCharCreateManyInput[]
  }

  /**
   * BoosterChar createManyAndReturn
   */
  export type BoosterCharCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BoosterChar
     */
    select?: BoosterCharSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BoosterChar
     */
    omit?: BoosterCharOmit<ExtArgs> | null
    /**
     * The data used to create many BoosterChars.
     */
    data: BoosterCharCreateManyInput | BoosterCharCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BoosterCharIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BoosterChar update
   */
  export type BoosterCharUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BoosterChar
     */
    select?: BoosterCharSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BoosterChar
     */
    omit?: BoosterCharOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BoosterCharInclude<ExtArgs> | null
    /**
     * The data needed to update a BoosterChar.
     */
    data: XOR<BoosterCharUpdateInput, BoosterCharUncheckedUpdateInput>
    /**
     * Choose, which BoosterChar to update.
     */
    where: BoosterCharWhereUniqueInput
  }

  /**
   * BoosterChar updateMany
   */
  export type BoosterCharUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BoosterChars.
     */
    data: XOR<BoosterCharUpdateManyMutationInput, BoosterCharUncheckedUpdateManyInput>
    /**
     * Filter which BoosterChars to update
     */
    where?: BoosterCharWhereInput
    /**
     * Limit how many BoosterChars to update.
     */
    limit?: number
  }

  /**
   * BoosterChar updateManyAndReturn
   */
  export type BoosterCharUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BoosterChar
     */
    select?: BoosterCharSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BoosterChar
     */
    omit?: BoosterCharOmit<ExtArgs> | null
    /**
     * The data used to update BoosterChars.
     */
    data: XOR<BoosterCharUpdateManyMutationInput, BoosterCharUncheckedUpdateManyInput>
    /**
     * Filter which BoosterChars to update
     */
    where?: BoosterCharWhereInput
    /**
     * Limit how many BoosterChars to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BoosterCharIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * BoosterChar upsert
   */
  export type BoosterCharUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BoosterChar
     */
    select?: BoosterCharSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BoosterChar
     */
    omit?: BoosterCharOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BoosterCharInclude<ExtArgs> | null
    /**
     * The filter to search for the BoosterChar to update in case it exists.
     */
    where: BoosterCharWhereUniqueInput
    /**
     * In case the BoosterChar found by the `where` argument doesn't exist, create a new BoosterChar with this data.
     */
    create: XOR<BoosterCharCreateInput, BoosterCharUncheckedCreateInput>
    /**
     * In case the BoosterChar was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BoosterCharUpdateInput, BoosterCharUncheckedUpdateInput>
  }

  /**
   * BoosterChar delete
   */
  export type BoosterCharDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BoosterChar
     */
    select?: BoosterCharSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BoosterChar
     */
    omit?: BoosterCharOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BoosterCharInclude<ExtArgs> | null
    /**
     * Filter which BoosterChar to delete.
     */
    where: BoosterCharWhereUniqueInput
  }

  /**
   * BoosterChar deleteMany
   */
  export type BoosterCharDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BoosterChars to delete
     */
    where?: BoosterCharWhereInput
    /**
     * Limit how many BoosterChars to delete.
     */
    limit?: number
  }

  /**
   * BoosterChar.signups
   */
  export type BoosterChar$signupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Signup
     */
    select?: SignupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Signup
     */
    omit?: SignupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SignupInclude<ExtArgs> | null
    where?: SignupWhereInput
    orderBy?: SignupOrderByWithRelationInput | SignupOrderByWithRelationInput[]
    cursor?: SignupWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SignupScalarFieldEnum | SignupScalarFieldEnum[]
  }

  /**
   * BoosterChar without action
   */
  export type BoosterCharDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BoosterChar
     */
    select?: BoosterCharSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BoosterChar
     */
    omit?: BoosterCharOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BoosterCharInclude<ExtArgs> | null
  }


  /**
   * Model Signup
   */

  export type AggregateSignup = {
    _count: SignupCountAggregateOutputType | null
    _avg: SignupAvgAggregateOutputType | null
    _sum: SignupSumAggregateOutputType | null
    _min: SignupMinAggregateOutputType | null
    _max: SignupMaxAggregateOutputType | null
  }

  export type SignupAvgAggregateOutputType = {
    id: number | null
    raidId: number | null
    charId: number | null
  }

  export type SignupSumAggregateOutputType = {
    id: number | null
    raidId: number | null
    charId: number | null
  }

  export type SignupMinAggregateOutputType = {
    id: number | null
    raidId: number | null
    userId: string | null
    type: $Enums.SignupType | null
    charId: number | null
    displayName: string | null
    saved: boolean | null
    note: string | null
    class: string | null
    status: $Enums.SignupStatus | null
    createdAt: Date | null
  }

  export type SignupMaxAggregateOutputType = {
    id: number | null
    raidId: number | null
    userId: string | null
    type: $Enums.SignupType | null
    charId: number | null
    displayName: string | null
    saved: boolean | null
    note: string | null
    class: string | null
    status: $Enums.SignupStatus | null
    createdAt: Date | null
  }

  export type SignupCountAggregateOutputType = {
    id: number
    raidId: number
    userId: number
    type: number
    charId: number
    displayName: number
    saved: number
    note: number
    class: number
    status: number
    createdAt: number
    _all: number
  }


  export type SignupAvgAggregateInputType = {
    id?: true
    raidId?: true
    charId?: true
  }

  export type SignupSumAggregateInputType = {
    id?: true
    raidId?: true
    charId?: true
  }

  export type SignupMinAggregateInputType = {
    id?: true
    raidId?: true
    userId?: true
    type?: true
    charId?: true
    displayName?: true
    saved?: true
    note?: true
    class?: true
    status?: true
    createdAt?: true
  }

  export type SignupMaxAggregateInputType = {
    id?: true
    raidId?: true
    userId?: true
    type?: true
    charId?: true
    displayName?: true
    saved?: true
    note?: true
    class?: true
    status?: true
    createdAt?: true
  }

  export type SignupCountAggregateInputType = {
    id?: true
    raidId?: true
    userId?: true
    type?: true
    charId?: true
    displayName?: true
    saved?: true
    note?: true
    class?: true
    status?: true
    createdAt?: true
    _all?: true
  }

  export type SignupAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Signup to aggregate.
     */
    where?: SignupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Signups to fetch.
     */
    orderBy?: SignupOrderByWithRelationInput | SignupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SignupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Signups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Signups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Signups
    **/
    _count?: true | SignupCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SignupAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SignupSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SignupMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SignupMaxAggregateInputType
  }

  export type GetSignupAggregateType<T extends SignupAggregateArgs> = {
        [P in keyof T & keyof AggregateSignup]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSignup[P]>
      : GetScalarType<T[P], AggregateSignup[P]>
  }




  export type SignupGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SignupWhereInput
    orderBy?: SignupOrderByWithAggregationInput | SignupOrderByWithAggregationInput[]
    by: SignupScalarFieldEnum[] | SignupScalarFieldEnum
    having?: SignupScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SignupCountAggregateInputType | true
    _avg?: SignupAvgAggregateInputType
    _sum?: SignupSumAggregateInputType
    _min?: SignupMinAggregateInputType
    _max?: SignupMaxAggregateInputType
  }

  export type SignupGroupByOutputType = {
    id: number
    raidId: number
    userId: string | null
    type: $Enums.SignupType
    charId: number | null
    displayName: string | null
    saved: boolean
    note: string | null
    class: string | null
    status: $Enums.SignupStatus
    createdAt: Date
    _count: SignupCountAggregateOutputType | null
    _avg: SignupAvgAggregateOutputType | null
    _sum: SignupSumAggregateOutputType | null
    _min: SignupMinAggregateOutputType | null
    _max: SignupMaxAggregateOutputType | null
  }

  type GetSignupGroupByPayload<T extends SignupGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SignupGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SignupGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SignupGroupByOutputType[P]>
            : GetScalarType<T[P], SignupGroupByOutputType[P]>
        }
      >
    >


  export type SignupSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    raidId?: boolean
    userId?: boolean
    type?: boolean
    charId?: boolean
    displayName?: boolean
    saved?: boolean
    note?: boolean
    class?: boolean
    status?: boolean
    createdAt?: boolean
    raid?: boolean | RaidDefaultArgs<ExtArgs>
    char?: boolean | Signup$charArgs<ExtArgs>
    user?: boolean | Signup$userArgs<ExtArgs>
  }, ExtArgs["result"]["signup"]>

  export type SignupSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    raidId?: boolean
    userId?: boolean
    type?: boolean
    charId?: boolean
    displayName?: boolean
    saved?: boolean
    note?: boolean
    class?: boolean
    status?: boolean
    createdAt?: boolean
    raid?: boolean | RaidDefaultArgs<ExtArgs>
    char?: boolean | Signup$charArgs<ExtArgs>
    user?: boolean | Signup$userArgs<ExtArgs>
  }, ExtArgs["result"]["signup"]>

  export type SignupSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    raidId?: boolean
    userId?: boolean
    type?: boolean
    charId?: boolean
    displayName?: boolean
    saved?: boolean
    note?: boolean
    class?: boolean
    status?: boolean
    createdAt?: boolean
    raid?: boolean | RaidDefaultArgs<ExtArgs>
    char?: boolean | Signup$charArgs<ExtArgs>
    user?: boolean | Signup$userArgs<ExtArgs>
  }, ExtArgs["result"]["signup"]>

  export type SignupSelectScalar = {
    id?: boolean
    raidId?: boolean
    userId?: boolean
    type?: boolean
    charId?: boolean
    displayName?: boolean
    saved?: boolean
    note?: boolean
    class?: boolean
    status?: boolean
    createdAt?: boolean
  }

  export type SignupOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "raidId" | "userId" | "type" | "charId" | "displayName" | "saved" | "note" | "class" | "status" | "createdAt", ExtArgs["result"]["signup"]>
  export type SignupInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    raid?: boolean | RaidDefaultArgs<ExtArgs>
    char?: boolean | Signup$charArgs<ExtArgs>
    user?: boolean | Signup$userArgs<ExtArgs>
  }
  export type SignupIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    raid?: boolean | RaidDefaultArgs<ExtArgs>
    char?: boolean | Signup$charArgs<ExtArgs>
    user?: boolean | Signup$userArgs<ExtArgs>
  }
  export type SignupIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    raid?: boolean | RaidDefaultArgs<ExtArgs>
    char?: boolean | Signup$charArgs<ExtArgs>
    user?: boolean | Signup$userArgs<ExtArgs>
  }

  export type $SignupPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Signup"
    objects: {
      raid: Prisma.$RaidPayload<ExtArgs>
      char: Prisma.$BoosterCharPayload<ExtArgs> | null
      user: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      raidId: number
      userId: string | null
      type: $Enums.SignupType
      charId: number | null
      displayName: string | null
      saved: boolean
      note: string | null
      class: string | null
      status: $Enums.SignupStatus
      createdAt: Date
    }, ExtArgs["result"]["signup"]>
    composites: {}
  }

  type SignupGetPayload<S extends boolean | null | undefined | SignupDefaultArgs> = $Result.GetResult<Prisma.$SignupPayload, S>

  type SignupCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SignupFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SignupCountAggregateInputType | true
    }

  export interface SignupDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Signup'], meta: { name: 'Signup' } }
    /**
     * Find zero or one Signup that matches the filter.
     * @param {SignupFindUniqueArgs} args - Arguments to find a Signup
     * @example
     * // Get one Signup
     * const signup = await prisma.signup.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SignupFindUniqueArgs>(args: SelectSubset<T, SignupFindUniqueArgs<ExtArgs>>): Prisma__SignupClient<$Result.GetResult<Prisma.$SignupPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Signup that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SignupFindUniqueOrThrowArgs} args - Arguments to find a Signup
     * @example
     * // Get one Signup
     * const signup = await prisma.signup.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SignupFindUniqueOrThrowArgs>(args: SelectSubset<T, SignupFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SignupClient<$Result.GetResult<Prisma.$SignupPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Signup that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SignupFindFirstArgs} args - Arguments to find a Signup
     * @example
     * // Get one Signup
     * const signup = await prisma.signup.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SignupFindFirstArgs>(args?: SelectSubset<T, SignupFindFirstArgs<ExtArgs>>): Prisma__SignupClient<$Result.GetResult<Prisma.$SignupPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Signup that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SignupFindFirstOrThrowArgs} args - Arguments to find a Signup
     * @example
     * // Get one Signup
     * const signup = await prisma.signup.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SignupFindFirstOrThrowArgs>(args?: SelectSubset<T, SignupFindFirstOrThrowArgs<ExtArgs>>): Prisma__SignupClient<$Result.GetResult<Prisma.$SignupPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Signups that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SignupFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Signups
     * const signups = await prisma.signup.findMany()
     * 
     * // Get first 10 Signups
     * const signups = await prisma.signup.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const signupWithIdOnly = await prisma.signup.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SignupFindManyArgs>(args?: SelectSubset<T, SignupFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SignupPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Signup.
     * @param {SignupCreateArgs} args - Arguments to create a Signup.
     * @example
     * // Create one Signup
     * const Signup = await prisma.signup.create({
     *   data: {
     *     // ... data to create a Signup
     *   }
     * })
     * 
     */
    create<T extends SignupCreateArgs>(args: SelectSubset<T, SignupCreateArgs<ExtArgs>>): Prisma__SignupClient<$Result.GetResult<Prisma.$SignupPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Signups.
     * @param {SignupCreateManyArgs} args - Arguments to create many Signups.
     * @example
     * // Create many Signups
     * const signup = await prisma.signup.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SignupCreateManyArgs>(args?: SelectSubset<T, SignupCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Signups and returns the data saved in the database.
     * @param {SignupCreateManyAndReturnArgs} args - Arguments to create many Signups.
     * @example
     * // Create many Signups
     * const signup = await prisma.signup.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Signups and only return the `id`
     * const signupWithIdOnly = await prisma.signup.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SignupCreateManyAndReturnArgs>(args?: SelectSubset<T, SignupCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SignupPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Signup.
     * @param {SignupDeleteArgs} args - Arguments to delete one Signup.
     * @example
     * // Delete one Signup
     * const Signup = await prisma.signup.delete({
     *   where: {
     *     // ... filter to delete one Signup
     *   }
     * })
     * 
     */
    delete<T extends SignupDeleteArgs>(args: SelectSubset<T, SignupDeleteArgs<ExtArgs>>): Prisma__SignupClient<$Result.GetResult<Prisma.$SignupPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Signup.
     * @param {SignupUpdateArgs} args - Arguments to update one Signup.
     * @example
     * // Update one Signup
     * const signup = await prisma.signup.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SignupUpdateArgs>(args: SelectSubset<T, SignupUpdateArgs<ExtArgs>>): Prisma__SignupClient<$Result.GetResult<Prisma.$SignupPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Signups.
     * @param {SignupDeleteManyArgs} args - Arguments to filter Signups to delete.
     * @example
     * // Delete a few Signups
     * const { count } = await prisma.signup.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SignupDeleteManyArgs>(args?: SelectSubset<T, SignupDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Signups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SignupUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Signups
     * const signup = await prisma.signup.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SignupUpdateManyArgs>(args: SelectSubset<T, SignupUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Signups and returns the data updated in the database.
     * @param {SignupUpdateManyAndReturnArgs} args - Arguments to update many Signups.
     * @example
     * // Update many Signups
     * const signup = await prisma.signup.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Signups and only return the `id`
     * const signupWithIdOnly = await prisma.signup.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SignupUpdateManyAndReturnArgs>(args: SelectSubset<T, SignupUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SignupPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Signup.
     * @param {SignupUpsertArgs} args - Arguments to update or create a Signup.
     * @example
     * // Update or create a Signup
     * const signup = await prisma.signup.upsert({
     *   create: {
     *     // ... data to create a Signup
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Signup we want to update
     *   }
     * })
     */
    upsert<T extends SignupUpsertArgs>(args: SelectSubset<T, SignupUpsertArgs<ExtArgs>>): Prisma__SignupClient<$Result.GetResult<Prisma.$SignupPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Signups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SignupCountArgs} args - Arguments to filter Signups to count.
     * @example
     * // Count the number of Signups
     * const count = await prisma.signup.count({
     *   where: {
     *     // ... the filter for the Signups we want to count
     *   }
     * })
    **/
    count<T extends SignupCountArgs>(
      args?: Subset<T, SignupCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SignupCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Signup.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SignupAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SignupAggregateArgs>(args: Subset<T, SignupAggregateArgs>): Prisma.PrismaPromise<GetSignupAggregateType<T>>

    /**
     * Group by Signup.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SignupGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SignupGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SignupGroupByArgs['orderBy'] }
        : { orderBy?: SignupGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SignupGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSignupGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Signup model
   */
  readonly fields: SignupFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Signup.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SignupClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    raid<T extends RaidDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RaidDefaultArgs<ExtArgs>>): Prisma__RaidClient<$Result.GetResult<Prisma.$RaidPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    char<T extends Signup$charArgs<ExtArgs> = {}>(args?: Subset<T, Signup$charArgs<ExtArgs>>): Prisma__BoosterCharClient<$Result.GetResult<Prisma.$BoosterCharPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    user<T extends Signup$userArgs<ExtArgs> = {}>(args?: Subset<T, Signup$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Signup model
   */
  interface SignupFieldRefs {
    readonly id: FieldRef<"Signup", 'Int'>
    readonly raidId: FieldRef<"Signup", 'Int'>
    readonly userId: FieldRef<"Signup", 'String'>
    readonly type: FieldRef<"Signup", 'SignupType'>
    readonly charId: FieldRef<"Signup", 'Int'>
    readonly displayName: FieldRef<"Signup", 'String'>
    readonly saved: FieldRef<"Signup", 'Boolean'>
    readonly note: FieldRef<"Signup", 'String'>
    readonly class: FieldRef<"Signup", 'String'>
    readonly status: FieldRef<"Signup", 'SignupStatus'>
    readonly createdAt: FieldRef<"Signup", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Signup findUnique
   */
  export type SignupFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Signup
     */
    select?: SignupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Signup
     */
    omit?: SignupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SignupInclude<ExtArgs> | null
    /**
     * Filter, which Signup to fetch.
     */
    where: SignupWhereUniqueInput
  }

  /**
   * Signup findUniqueOrThrow
   */
  export type SignupFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Signup
     */
    select?: SignupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Signup
     */
    omit?: SignupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SignupInclude<ExtArgs> | null
    /**
     * Filter, which Signup to fetch.
     */
    where: SignupWhereUniqueInput
  }

  /**
   * Signup findFirst
   */
  export type SignupFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Signup
     */
    select?: SignupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Signup
     */
    omit?: SignupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SignupInclude<ExtArgs> | null
    /**
     * Filter, which Signup to fetch.
     */
    where?: SignupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Signups to fetch.
     */
    orderBy?: SignupOrderByWithRelationInput | SignupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Signups.
     */
    cursor?: SignupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Signups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Signups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Signups.
     */
    distinct?: SignupScalarFieldEnum | SignupScalarFieldEnum[]
  }

  /**
   * Signup findFirstOrThrow
   */
  export type SignupFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Signup
     */
    select?: SignupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Signup
     */
    omit?: SignupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SignupInclude<ExtArgs> | null
    /**
     * Filter, which Signup to fetch.
     */
    where?: SignupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Signups to fetch.
     */
    orderBy?: SignupOrderByWithRelationInput | SignupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Signups.
     */
    cursor?: SignupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Signups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Signups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Signups.
     */
    distinct?: SignupScalarFieldEnum | SignupScalarFieldEnum[]
  }

  /**
   * Signup findMany
   */
  export type SignupFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Signup
     */
    select?: SignupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Signup
     */
    omit?: SignupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SignupInclude<ExtArgs> | null
    /**
     * Filter, which Signups to fetch.
     */
    where?: SignupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Signups to fetch.
     */
    orderBy?: SignupOrderByWithRelationInput | SignupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Signups.
     */
    cursor?: SignupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Signups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Signups.
     */
    skip?: number
    distinct?: SignupScalarFieldEnum | SignupScalarFieldEnum[]
  }

  /**
   * Signup create
   */
  export type SignupCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Signup
     */
    select?: SignupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Signup
     */
    omit?: SignupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SignupInclude<ExtArgs> | null
    /**
     * The data needed to create a Signup.
     */
    data: XOR<SignupCreateInput, SignupUncheckedCreateInput>
  }

  /**
   * Signup createMany
   */
  export type SignupCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Signups.
     */
    data: SignupCreateManyInput | SignupCreateManyInput[]
  }

  /**
   * Signup createManyAndReturn
   */
  export type SignupCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Signup
     */
    select?: SignupSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Signup
     */
    omit?: SignupOmit<ExtArgs> | null
    /**
     * The data used to create many Signups.
     */
    data: SignupCreateManyInput | SignupCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SignupIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Signup update
   */
  export type SignupUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Signup
     */
    select?: SignupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Signup
     */
    omit?: SignupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SignupInclude<ExtArgs> | null
    /**
     * The data needed to update a Signup.
     */
    data: XOR<SignupUpdateInput, SignupUncheckedUpdateInput>
    /**
     * Choose, which Signup to update.
     */
    where: SignupWhereUniqueInput
  }

  /**
   * Signup updateMany
   */
  export type SignupUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Signups.
     */
    data: XOR<SignupUpdateManyMutationInput, SignupUncheckedUpdateManyInput>
    /**
     * Filter which Signups to update
     */
    where?: SignupWhereInput
    /**
     * Limit how many Signups to update.
     */
    limit?: number
  }

  /**
   * Signup updateManyAndReturn
   */
  export type SignupUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Signup
     */
    select?: SignupSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Signup
     */
    omit?: SignupOmit<ExtArgs> | null
    /**
     * The data used to update Signups.
     */
    data: XOR<SignupUpdateManyMutationInput, SignupUncheckedUpdateManyInput>
    /**
     * Filter which Signups to update
     */
    where?: SignupWhereInput
    /**
     * Limit how many Signups to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SignupIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Signup upsert
   */
  export type SignupUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Signup
     */
    select?: SignupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Signup
     */
    omit?: SignupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SignupInclude<ExtArgs> | null
    /**
     * The filter to search for the Signup to update in case it exists.
     */
    where: SignupWhereUniqueInput
    /**
     * In case the Signup found by the `where` argument doesn't exist, create a new Signup with this data.
     */
    create: XOR<SignupCreateInput, SignupUncheckedCreateInput>
    /**
     * In case the Signup was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SignupUpdateInput, SignupUncheckedUpdateInput>
  }

  /**
   * Signup delete
   */
  export type SignupDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Signup
     */
    select?: SignupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Signup
     */
    omit?: SignupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SignupInclude<ExtArgs> | null
    /**
     * Filter which Signup to delete.
     */
    where: SignupWhereUniqueInput
  }

  /**
   * Signup deleteMany
   */
  export type SignupDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Signups to delete
     */
    where?: SignupWhereInput
    /**
     * Limit how many Signups to delete.
     */
    limit?: number
  }

  /**
   * Signup.char
   */
  export type Signup$charArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BoosterChar
     */
    select?: BoosterCharSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BoosterChar
     */
    omit?: BoosterCharOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BoosterCharInclude<ExtArgs> | null
    where?: BoosterCharWhereInput
  }

  /**
   * Signup.user
   */
  export type Signup$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Signup without action
   */
  export type SignupDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Signup
     */
    select?: SignupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Signup
     */
    omit?: SignupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SignupInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    discordId: 'discordId',
    username: 'username',
    displayName: 'displayName',
    avatarUrl: 'avatarUrl',
    rolesCsv: 'rolesCsv',
    isRaidlead: 'isRaidlead',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const RaidScalarFieldEnum: {
    id: 'id',
    title: 'title',
    difficulty: 'difficulty',
    lootType: 'lootType',
    date: 'date',
    lead: 'lead',
    bosses: 'bosses',
    tanks: 'tanks',
    healers: 'healers',
    dps: 'dps',
    lootbuddies: 'lootbuddies',
    channelId: 'channelId',
    messageId: 'messageId',
    presetId: 'presetId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RaidScalarFieldEnum = (typeof RaidScalarFieldEnum)[keyof typeof RaidScalarFieldEnum]


  export const PresetScalarFieldEnum: {
    id: 'id',
    name: 'name',
    tanks: 'tanks',
    healers: 'healers',
    dps: 'dps',
    lootbuddies: 'lootbuddies'
  };

  export type PresetScalarFieldEnum = (typeof PresetScalarFieldEnum)[keyof typeof PresetScalarFieldEnum]


  export const BoosterCharScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    name: 'name',
    realm: 'realm',
    class: 'class',
    spec: 'spec',
    rioScore: 'rioScore',
    progress: 'progress',
    itemLevel: 'itemLevel',
    wclUrl: 'wclUrl',
    updatedAt: 'updatedAt'
  };

  export type BoosterCharScalarFieldEnum = (typeof BoosterCharScalarFieldEnum)[keyof typeof BoosterCharScalarFieldEnum]


  export const SignupScalarFieldEnum: {
    id: 'id',
    raidId: 'raidId',
    userId: 'userId',
    type: 'type',
    charId: 'charId',
    displayName: 'displayName',
    saved: 'saved',
    note: 'note',
    class: 'class',
    status: 'status',
    createdAt: 'createdAt'
  };

  export type SignupScalarFieldEnum = (typeof SignupScalarFieldEnum)[keyof typeof SignupScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'SignupType'
   */
  export type EnumSignupTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SignupType'>
    


  /**
   * Reference to a field of type 'SignupStatus'
   */
  export type EnumSignupStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SignupStatus'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: IntFilter<"User"> | number
    discordId?: StringFilter<"User"> | string
    username?: StringNullableFilter<"User"> | string | null
    displayName?: StringNullableFilter<"User"> | string | null
    avatarUrl?: StringNullableFilter<"User"> | string | null
    rolesCsv?: StringNullableFilter<"User"> | string | null
    isRaidlead?: BoolFilter<"User"> | boolean
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    chars?: BoosterCharListRelationFilter
    signups?: SignupListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    discordId?: SortOrder
    username?: SortOrderInput | SortOrder
    displayName?: SortOrderInput | SortOrder
    avatarUrl?: SortOrderInput | SortOrder
    rolesCsv?: SortOrderInput | SortOrder
    isRaidlead?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    chars?: BoosterCharOrderByRelationAggregateInput
    signups?: SignupOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    discordId?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    username?: StringNullableFilter<"User"> | string | null
    displayName?: StringNullableFilter<"User"> | string | null
    avatarUrl?: StringNullableFilter<"User"> | string | null
    rolesCsv?: StringNullableFilter<"User"> | string | null
    isRaidlead?: BoolFilter<"User"> | boolean
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    chars?: BoosterCharListRelationFilter
    signups?: SignupListRelationFilter
  }, "id" | "discordId">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    discordId?: SortOrder
    username?: SortOrderInput | SortOrder
    displayName?: SortOrderInput | SortOrder
    avatarUrl?: SortOrderInput | SortOrder
    rolesCsv?: SortOrderInput | SortOrder
    isRaidlead?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"User"> | number
    discordId?: StringWithAggregatesFilter<"User"> | string
    username?: StringNullableWithAggregatesFilter<"User"> | string | null
    displayName?: StringNullableWithAggregatesFilter<"User"> | string | null
    avatarUrl?: StringNullableWithAggregatesFilter<"User"> | string | null
    rolesCsv?: StringNullableWithAggregatesFilter<"User"> | string | null
    isRaidlead?: BoolWithAggregatesFilter<"User"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type RaidWhereInput = {
    AND?: RaidWhereInput | RaidWhereInput[]
    OR?: RaidWhereInput[]
    NOT?: RaidWhereInput | RaidWhereInput[]
    id?: IntFilter<"Raid"> | number
    title?: StringFilter<"Raid"> | string
    difficulty?: StringFilter<"Raid"> | string
    lootType?: StringFilter<"Raid"> | string
    date?: DateTimeFilter<"Raid"> | Date | string
    lead?: StringNullableFilter<"Raid"> | string | null
    bosses?: IntFilter<"Raid"> | number
    tanks?: IntFilter<"Raid"> | number
    healers?: IntFilter<"Raid"> | number
    dps?: IntFilter<"Raid"> | number
    lootbuddies?: IntFilter<"Raid"> | number
    channelId?: StringNullableFilter<"Raid"> | string | null
    messageId?: StringNullableFilter<"Raid"> | string | null
    presetId?: IntNullableFilter<"Raid"> | number | null
    createdAt?: DateTimeFilter<"Raid"> | Date | string
    updatedAt?: DateTimeFilter<"Raid"> | Date | string
    preset?: XOR<PresetNullableScalarRelationFilter, PresetWhereInput> | null
    signups?: SignupListRelationFilter
  }

  export type RaidOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    difficulty?: SortOrder
    lootType?: SortOrder
    date?: SortOrder
    lead?: SortOrderInput | SortOrder
    bosses?: SortOrder
    tanks?: SortOrder
    healers?: SortOrder
    dps?: SortOrder
    lootbuddies?: SortOrder
    channelId?: SortOrderInput | SortOrder
    messageId?: SortOrderInput | SortOrder
    presetId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    preset?: PresetOrderByWithRelationInput
    signups?: SignupOrderByRelationAggregateInput
  }

  export type RaidWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: RaidWhereInput | RaidWhereInput[]
    OR?: RaidWhereInput[]
    NOT?: RaidWhereInput | RaidWhereInput[]
    title?: StringFilter<"Raid"> | string
    difficulty?: StringFilter<"Raid"> | string
    lootType?: StringFilter<"Raid"> | string
    date?: DateTimeFilter<"Raid"> | Date | string
    lead?: StringNullableFilter<"Raid"> | string | null
    bosses?: IntFilter<"Raid"> | number
    tanks?: IntFilter<"Raid"> | number
    healers?: IntFilter<"Raid"> | number
    dps?: IntFilter<"Raid"> | number
    lootbuddies?: IntFilter<"Raid"> | number
    channelId?: StringNullableFilter<"Raid"> | string | null
    messageId?: StringNullableFilter<"Raid"> | string | null
    presetId?: IntNullableFilter<"Raid"> | number | null
    createdAt?: DateTimeFilter<"Raid"> | Date | string
    updatedAt?: DateTimeFilter<"Raid"> | Date | string
    preset?: XOR<PresetNullableScalarRelationFilter, PresetWhereInput> | null
    signups?: SignupListRelationFilter
  }, "id">

  export type RaidOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    difficulty?: SortOrder
    lootType?: SortOrder
    date?: SortOrder
    lead?: SortOrderInput | SortOrder
    bosses?: SortOrder
    tanks?: SortOrder
    healers?: SortOrder
    dps?: SortOrder
    lootbuddies?: SortOrder
    channelId?: SortOrderInput | SortOrder
    messageId?: SortOrderInput | SortOrder
    presetId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RaidCountOrderByAggregateInput
    _avg?: RaidAvgOrderByAggregateInput
    _max?: RaidMaxOrderByAggregateInput
    _min?: RaidMinOrderByAggregateInput
    _sum?: RaidSumOrderByAggregateInput
  }

  export type RaidScalarWhereWithAggregatesInput = {
    AND?: RaidScalarWhereWithAggregatesInput | RaidScalarWhereWithAggregatesInput[]
    OR?: RaidScalarWhereWithAggregatesInput[]
    NOT?: RaidScalarWhereWithAggregatesInput | RaidScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Raid"> | number
    title?: StringWithAggregatesFilter<"Raid"> | string
    difficulty?: StringWithAggregatesFilter<"Raid"> | string
    lootType?: StringWithAggregatesFilter<"Raid"> | string
    date?: DateTimeWithAggregatesFilter<"Raid"> | Date | string
    lead?: StringNullableWithAggregatesFilter<"Raid"> | string | null
    bosses?: IntWithAggregatesFilter<"Raid"> | number
    tanks?: IntWithAggregatesFilter<"Raid"> | number
    healers?: IntWithAggregatesFilter<"Raid"> | number
    dps?: IntWithAggregatesFilter<"Raid"> | number
    lootbuddies?: IntWithAggregatesFilter<"Raid"> | number
    channelId?: StringNullableWithAggregatesFilter<"Raid"> | string | null
    messageId?: StringNullableWithAggregatesFilter<"Raid"> | string | null
    presetId?: IntNullableWithAggregatesFilter<"Raid"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"Raid"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Raid"> | Date | string
  }

  export type PresetWhereInput = {
    AND?: PresetWhereInput | PresetWhereInput[]
    OR?: PresetWhereInput[]
    NOT?: PresetWhereInput | PresetWhereInput[]
    id?: IntFilter<"Preset"> | number
    name?: StringFilter<"Preset"> | string
    tanks?: IntFilter<"Preset"> | number
    healers?: IntFilter<"Preset"> | number
    dps?: IntFilter<"Preset"> | number
    lootbuddies?: IntFilter<"Preset"> | number
    raids?: RaidListRelationFilter
  }

  export type PresetOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    tanks?: SortOrder
    healers?: SortOrder
    dps?: SortOrder
    lootbuddies?: SortOrder
    raids?: RaidOrderByRelationAggregateInput
  }

  export type PresetWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PresetWhereInput | PresetWhereInput[]
    OR?: PresetWhereInput[]
    NOT?: PresetWhereInput | PresetWhereInput[]
    name?: StringFilter<"Preset"> | string
    tanks?: IntFilter<"Preset"> | number
    healers?: IntFilter<"Preset"> | number
    dps?: IntFilter<"Preset"> | number
    lootbuddies?: IntFilter<"Preset"> | number
    raids?: RaidListRelationFilter
  }, "id">

  export type PresetOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    tanks?: SortOrder
    healers?: SortOrder
    dps?: SortOrder
    lootbuddies?: SortOrder
    _count?: PresetCountOrderByAggregateInput
    _avg?: PresetAvgOrderByAggregateInput
    _max?: PresetMaxOrderByAggregateInput
    _min?: PresetMinOrderByAggregateInput
    _sum?: PresetSumOrderByAggregateInput
  }

  export type PresetScalarWhereWithAggregatesInput = {
    AND?: PresetScalarWhereWithAggregatesInput | PresetScalarWhereWithAggregatesInput[]
    OR?: PresetScalarWhereWithAggregatesInput[]
    NOT?: PresetScalarWhereWithAggregatesInput | PresetScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Preset"> | number
    name?: StringWithAggregatesFilter<"Preset"> | string
    tanks?: IntWithAggregatesFilter<"Preset"> | number
    healers?: IntWithAggregatesFilter<"Preset"> | number
    dps?: IntWithAggregatesFilter<"Preset"> | number
    lootbuddies?: IntWithAggregatesFilter<"Preset"> | number
  }

  export type BoosterCharWhereInput = {
    AND?: BoosterCharWhereInput | BoosterCharWhereInput[]
    OR?: BoosterCharWhereInput[]
    NOT?: BoosterCharWhereInput | BoosterCharWhereInput[]
    id?: IntFilter<"BoosterChar"> | number
    userId?: StringFilter<"BoosterChar"> | string
    name?: StringFilter<"BoosterChar"> | string
    realm?: StringFilter<"BoosterChar"> | string
    class?: StringNullableFilter<"BoosterChar"> | string | null
    spec?: StringNullableFilter<"BoosterChar"> | string | null
    rioScore?: FloatNullableFilter<"BoosterChar"> | number | null
    progress?: StringNullableFilter<"BoosterChar"> | string | null
    itemLevel?: IntNullableFilter<"BoosterChar"> | number | null
    wclUrl?: StringNullableFilter<"BoosterChar"> | string | null
    updatedAt?: DateTimeFilter<"BoosterChar"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    signups?: SignupListRelationFilter
  }

  export type BoosterCharOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    realm?: SortOrder
    class?: SortOrderInput | SortOrder
    spec?: SortOrderInput | SortOrder
    rioScore?: SortOrderInput | SortOrder
    progress?: SortOrderInput | SortOrder
    itemLevel?: SortOrderInput | SortOrder
    wclUrl?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    signups?: SignupOrderByRelationAggregateInput
  }

  export type BoosterCharWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: BoosterCharWhereInput | BoosterCharWhereInput[]
    OR?: BoosterCharWhereInput[]
    NOT?: BoosterCharWhereInput | BoosterCharWhereInput[]
    userId?: StringFilter<"BoosterChar"> | string
    name?: StringFilter<"BoosterChar"> | string
    realm?: StringFilter<"BoosterChar"> | string
    class?: StringNullableFilter<"BoosterChar"> | string | null
    spec?: StringNullableFilter<"BoosterChar"> | string | null
    rioScore?: FloatNullableFilter<"BoosterChar"> | number | null
    progress?: StringNullableFilter<"BoosterChar"> | string | null
    itemLevel?: IntNullableFilter<"BoosterChar"> | number | null
    wclUrl?: StringNullableFilter<"BoosterChar"> | string | null
    updatedAt?: DateTimeFilter<"BoosterChar"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    signups?: SignupListRelationFilter
  }, "id">

  export type BoosterCharOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    realm?: SortOrder
    class?: SortOrderInput | SortOrder
    spec?: SortOrderInput | SortOrder
    rioScore?: SortOrderInput | SortOrder
    progress?: SortOrderInput | SortOrder
    itemLevel?: SortOrderInput | SortOrder
    wclUrl?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    _count?: BoosterCharCountOrderByAggregateInput
    _avg?: BoosterCharAvgOrderByAggregateInput
    _max?: BoosterCharMaxOrderByAggregateInput
    _min?: BoosterCharMinOrderByAggregateInput
    _sum?: BoosterCharSumOrderByAggregateInput
  }

  export type BoosterCharScalarWhereWithAggregatesInput = {
    AND?: BoosterCharScalarWhereWithAggregatesInput | BoosterCharScalarWhereWithAggregatesInput[]
    OR?: BoosterCharScalarWhereWithAggregatesInput[]
    NOT?: BoosterCharScalarWhereWithAggregatesInput | BoosterCharScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"BoosterChar"> | number
    userId?: StringWithAggregatesFilter<"BoosterChar"> | string
    name?: StringWithAggregatesFilter<"BoosterChar"> | string
    realm?: StringWithAggregatesFilter<"BoosterChar"> | string
    class?: StringNullableWithAggregatesFilter<"BoosterChar"> | string | null
    spec?: StringNullableWithAggregatesFilter<"BoosterChar"> | string | null
    rioScore?: FloatNullableWithAggregatesFilter<"BoosterChar"> | number | null
    progress?: StringNullableWithAggregatesFilter<"BoosterChar"> | string | null
    itemLevel?: IntNullableWithAggregatesFilter<"BoosterChar"> | number | null
    wclUrl?: StringNullableWithAggregatesFilter<"BoosterChar"> | string | null
    updatedAt?: DateTimeWithAggregatesFilter<"BoosterChar"> | Date | string
  }

  export type SignupWhereInput = {
    AND?: SignupWhereInput | SignupWhereInput[]
    OR?: SignupWhereInput[]
    NOT?: SignupWhereInput | SignupWhereInput[]
    id?: IntFilter<"Signup"> | number
    raidId?: IntFilter<"Signup"> | number
    userId?: StringNullableFilter<"Signup"> | string | null
    type?: EnumSignupTypeFilter<"Signup"> | $Enums.SignupType
    charId?: IntNullableFilter<"Signup"> | number | null
    displayName?: StringNullableFilter<"Signup"> | string | null
    saved?: BoolFilter<"Signup"> | boolean
    note?: StringNullableFilter<"Signup"> | string | null
    class?: StringNullableFilter<"Signup"> | string | null
    status?: EnumSignupStatusFilter<"Signup"> | $Enums.SignupStatus
    createdAt?: DateTimeFilter<"Signup"> | Date | string
    raid?: XOR<RaidScalarRelationFilter, RaidWhereInput>
    char?: XOR<BoosterCharNullableScalarRelationFilter, BoosterCharWhereInput> | null
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type SignupOrderByWithRelationInput = {
    id?: SortOrder
    raidId?: SortOrder
    userId?: SortOrderInput | SortOrder
    type?: SortOrder
    charId?: SortOrderInput | SortOrder
    displayName?: SortOrderInput | SortOrder
    saved?: SortOrder
    note?: SortOrderInput | SortOrder
    class?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    raid?: RaidOrderByWithRelationInput
    char?: BoosterCharOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type SignupWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: SignupWhereInput | SignupWhereInput[]
    OR?: SignupWhereInput[]
    NOT?: SignupWhereInput | SignupWhereInput[]
    raidId?: IntFilter<"Signup"> | number
    userId?: StringNullableFilter<"Signup"> | string | null
    type?: EnumSignupTypeFilter<"Signup"> | $Enums.SignupType
    charId?: IntNullableFilter<"Signup"> | number | null
    displayName?: StringNullableFilter<"Signup"> | string | null
    saved?: BoolFilter<"Signup"> | boolean
    note?: StringNullableFilter<"Signup"> | string | null
    class?: StringNullableFilter<"Signup"> | string | null
    status?: EnumSignupStatusFilter<"Signup"> | $Enums.SignupStatus
    createdAt?: DateTimeFilter<"Signup"> | Date | string
    raid?: XOR<RaidScalarRelationFilter, RaidWhereInput>
    char?: XOR<BoosterCharNullableScalarRelationFilter, BoosterCharWhereInput> | null
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type SignupOrderByWithAggregationInput = {
    id?: SortOrder
    raidId?: SortOrder
    userId?: SortOrderInput | SortOrder
    type?: SortOrder
    charId?: SortOrderInput | SortOrder
    displayName?: SortOrderInput | SortOrder
    saved?: SortOrder
    note?: SortOrderInput | SortOrder
    class?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    _count?: SignupCountOrderByAggregateInput
    _avg?: SignupAvgOrderByAggregateInput
    _max?: SignupMaxOrderByAggregateInput
    _min?: SignupMinOrderByAggregateInput
    _sum?: SignupSumOrderByAggregateInput
  }

  export type SignupScalarWhereWithAggregatesInput = {
    AND?: SignupScalarWhereWithAggregatesInput | SignupScalarWhereWithAggregatesInput[]
    OR?: SignupScalarWhereWithAggregatesInput[]
    NOT?: SignupScalarWhereWithAggregatesInput | SignupScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Signup"> | number
    raidId?: IntWithAggregatesFilter<"Signup"> | number
    userId?: StringNullableWithAggregatesFilter<"Signup"> | string | null
    type?: EnumSignupTypeWithAggregatesFilter<"Signup"> | $Enums.SignupType
    charId?: IntNullableWithAggregatesFilter<"Signup"> | number | null
    displayName?: StringNullableWithAggregatesFilter<"Signup"> | string | null
    saved?: BoolWithAggregatesFilter<"Signup"> | boolean
    note?: StringNullableWithAggregatesFilter<"Signup"> | string | null
    class?: StringNullableWithAggregatesFilter<"Signup"> | string | null
    status?: EnumSignupStatusWithAggregatesFilter<"Signup"> | $Enums.SignupStatus
    createdAt?: DateTimeWithAggregatesFilter<"Signup"> | Date | string
  }

  export type UserCreateInput = {
    discordId: string
    username?: string | null
    displayName?: string | null
    avatarUrl?: string | null
    rolesCsv?: string | null
    isRaidlead?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    chars?: BoosterCharCreateNestedManyWithoutUserInput
    signups?: SignupCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: number
    discordId: string
    username?: string | null
    displayName?: string | null
    avatarUrl?: string | null
    rolesCsv?: string | null
    isRaidlead?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    chars?: BoosterCharUncheckedCreateNestedManyWithoutUserInput
    signups?: SignupUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    discordId?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    rolesCsv?: NullableStringFieldUpdateOperationsInput | string | null
    isRaidlead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chars?: BoosterCharUpdateManyWithoutUserNestedInput
    signups?: SignupUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    discordId?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    rolesCsv?: NullableStringFieldUpdateOperationsInput | string | null
    isRaidlead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chars?: BoosterCharUncheckedUpdateManyWithoutUserNestedInput
    signups?: SignupUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: number
    discordId: string
    username?: string | null
    displayName?: string | null
    avatarUrl?: string | null
    rolesCsv?: string | null
    isRaidlead?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    discordId?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    rolesCsv?: NullableStringFieldUpdateOperationsInput | string | null
    isRaidlead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    discordId?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    rolesCsv?: NullableStringFieldUpdateOperationsInput | string | null
    isRaidlead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RaidCreateInput = {
    title: string
    difficulty: string
    lootType: string
    date: Date | string
    lead?: string | null
    bosses: number
    tanks?: number
    healers?: number
    dps?: number
    lootbuddies?: number
    channelId?: string | null
    messageId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    preset?: PresetCreateNestedOneWithoutRaidsInput
    signups?: SignupCreateNestedManyWithoutRaidInput
  }

  export type RaidUncheckedCreateInput = {
    id?: number
    title: string
    difficulty: string
    lootType: string
    date: Date | string
    lead?: string | null
    bosses: number
    tanks?: number
    healers?: number
    dps?: number
    lootbuddies?: number
    channelId?: string | null
    messageId?: string | null
    presetId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    signups?: SignupUncheckedCreateNestedManyWithoutRaidInput
  }

  export type RaidUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    difficulty?: StringFieldUpdateOperationsInput | string
    lootType?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    lead?: NullableStringFieldUpdateOperationsInput | string | null
    bosses?: IntFieldUpdateOperationsInput | number
    tanks?: IntFieldUpdateOperationsInput | number
    healers?: IntFieldUpdateOperationsInput | number
    dps?: IntFieldUpdateOperationsInput | number
    lootbuddies?: IntFieldUpdateOperationsInput | number
    channelId?: NullableStringFieldUpdateOperationsInput | string | null
    messageId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    preset?: PresetUpdateOneWithoutRaidsNestedInput
    signups?: SignupUpdateManyWithoutRaidNestedInput
  }

  export type RaidUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    difficulty?: StringFieldUpdateOperationsInput | string
    lootType?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    lead?: NullableStringFieldUpdateOperationsInput | string | null
    bosses?: IntFieldUpdateOperationsInput | number
    tanks?: IntFieldUpdateOperationsInput | number
    healers?: IntFieldUpdateOperationsInput | number
    dps?: IntFieldUpdateOperationsInput | number
    lootbuddies?: IntFieldUpdateOperationsInput | number
    channelId?: NullableStringFieldUpdateOperationsInput | string | null
    messageId?: NullableStringFieldUpdateOperationsInput | string | null
    presetId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    signups?: SignupUncheckedUpdateManyWithoutRaidNestedInput
  }

  export type RaidCreateManyInput = {
    id?: number
    title: string
    difficulty: string
    lootType: string
    date: Date | string
    lead?: string | null
    bosses: number
    tanks?: number
    healers?: number
    dps?: number
    lootbuddies?: number
    channelId?: string | null
    messageId?: string | null
    presetId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RaidUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    difficulty?: StringFieldUpdateOperationsInput | string
    lootType?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    lead?: NullableStringFieldUpdateOperationsInput | string | null
    bosses?: IntFieldUpdateOperationsInput | number
    tanks?: IntFieldUpdateOperationsInput | number
    healers?: IntFieldUpdateOperationsInput | number
    dps?: IntFieldUpdateOperationsInput | number
    lootbuddies?: IntFieldUpdateOperationsInput | number
    channelId?: NullableStringFieldUpdateOperationsInput | string | null
    messageId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RaidUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    difficulty?: StringFieldUpdateOperationsInput | string
    lootType?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    lead?: NullableStringFieldUpdateOperationsInput | string | null
    bosses?: IntFieldUpdateOperationsInput | number
    tanks?: IntFieldUpdateOperationsInput | number
    healers?: IntFieldUpdateOperationsInput | number
    dps?: IntFieldUpdateOperationsInput | number
    lootbuddies?: IntFieldUpdateOperationsInput | number
    channelId?: NullableStringFieldUpdateOperationsInput | string | null
    messageId?: NullableStringFieldUpdateOperationsInput | string | null
    presetId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PresetCreateInput = {
    name: string
    tanks?: number
    healers?: number
    dps?: number
    lootbuddies?: number
    raids?: RaidCreateNestedManyWithoutPresetInput
  }

  export type PresetUncheckedCreateInput = {
    id?: number
    name: string
    tanks?: number
    healers?: number
    dps?: number
    lootbuddies?: number
    raids?: RaidUncheckedCreateNestedManyWithoutPresetInput
  }

  export type PresetUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    tanks?: IntFieldUpdateOperationsInput | number
    healers?: IntFieldUpdateOperationsInput | number
    dps?: IntFieldUpdateOperationsInput | number
    lootbuddies?: IntFieldUpdateOperationsInput | number
    raids?: RaidUpdateManyWithoutPresetNestedInput
  }

  export type PresetUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    tanks?: IntFieldUpdateOperationsInput | number
    healers?: IntFieldUpdateOperationsInput | number
    dps?: IntFieldUpdateOperationsInput | number
    lootbuddies?: IntFieldUpdateOperationsInput | number
    raids?: RaidUncheckedUpdateManyWithoutPresetNestedInput
  }

  export type PresetCreateManyInput = {
    id?: number
    name: string
    tanks?: number
    healers?: number
    dps?: number
    lootbuddies?: number
  }

  export type PresetUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    tanks?: IntFieldUpdateOperationsInput | number
    healers?: IntFieldUpdateOperationsInput | number
    dps?: IntFieldUpdateOperationsInput | number
    lootbuddies?: IntFieldUpdateOperationsInput | number
  }

  export type PresetUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    tanks?: IntFieldUpdateOperationsInput | number
    healers?: IntFieldUpdateOperationsInput | number
    dps?: IntFieldUpdateOperationsInput | number
    lootbuddies?: IntFieldUpdateOperationsInput | number
  }

  export type BoosterCharCreateInput = {
    name: string
    realm: string
    class?: string | null
    spec?: string | null
    rioScore?: number | null
    progress?: string | null
    itemLevel?: number | null
    wclUrl?: string | null
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutCharsInput
    signups?: SignupCreateNestedManyWithoutCharInput
  }

  export type BoosterCharUncheckedCreateInput = {
    id?: number
    userId: string
    name: string
    realm: string
    class?: string | null
    spec?: string | null
    rioScore?: number | null
    progress?: string | null
    itemLevel?: number | null
    wclUrl?: string | null
    updatedAt?: Date | string
    signups?: SignupUncheckedCreateNestedManyWithoutCharInput
  }

  export type BoosterCharUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    realm?: StringFieldUpdateOperationsInput | string
    class?: NullableStringFieldUpdateOperationsInput | string | null
    spec?: NullableStringFieldUpdateOperationsInput | string | null
    rioScore?: NullableFloatFieldUpdateOperationsInput | number | null
    progress?: NullableStringFieldUpdateOperationsInput | string | null
    itemLevel?: NullableIntFieldUpdateOperationsInput | number | null
    wclUrl?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCharsNestedInput
    signups?: SignupUpdateManyWithoutCharNestedInput
  }

  export type BoosterCharUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    realm?: StringFieldUpdateOperationsInput | string
    class?: NullableStringFieldUpdateOperationsInput | string | null
    spec?: NullableStringFieldUpdateOperationsInput | string | null
    rioScore?: NullableFloatFieldUpdateOperationsInput | number | null
    progress?: NullableStringFieldUpdateOperationsInput | string | null
    itemLevel?: NullableIntFieldUpdateOperationsInput | number | null
    wclUrl?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    signups?: SignupUncheckedUpdateManyWithoutCharNestedInput
  }

  export type BoosterCharCreateManyInput = {
    id?: number
    userId: string
    name: string
    realm: string
    class?: string | null
    spec?: string | null
    rioScore?: number | null
    progress?: string | null
    itemLevel?: number | null
    wclUrl?: string | null
    updatedAt?: Date | string
  }

  export type BoosterCharUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    realm?: StringFieldUpdateOperationsInput | string
    class?: NullableStringFieldUpdateOperationsInput | string | null
    spec?: NullableStringFieldUpdateOperationsInput | string | null
    rioScore?: NullableFloatFieldUpdateOperationsInput | number | null
    progress?: NullableStringFieldUpdateOperationsInput | string | null
    itemLevel?: NullableIntFieldUpdateOperationsInput | number | null
    wclUrl?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BoosterCharUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    realm?: StringFieldUpdateOperationsInput | string
    class?: NullableStringFieldUpdateOperationsInput | string | null
    spec?: NullableStringFieldUpdateOperationsInput | string | null
    rioScore?: NullableFloatFieldUpdateOperationsInput | number | null
    progress?: NullableStringFieldUpdateOperationsInput | string | null
    itemLevel?: NullableIntFieldUpdateOperationsInput | number | null
    wclUrl?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SignupCreateInput = {
    type: $Enums.SignupType
    displayName?: string | null
    saved?: boolean
    note?: string | null
    class?: string | null
    status?: $Enums.SignupStatus
    createdAt?: Date | string
    raid: RaidCreateNestedOneWithoutSignupsInput
    char?: BoosterCharCreateNestedOneWithoutSignupsInput
    user?: UserCreateNestedOneWithoutSignupsInput
  }

  export type SignupUncheckedCreateInput = {
    id?: number
    raidId: number
    userId?: string | null
    type: $Enums.SignupType
    charId?: number | null
    displayName?: string | null
    saved?: boolean
    note?: string | null
    class?: string | null
    status?: $Enums.SignupStatus
    createdAt?: Date | string
  }

  export type SignupUpdateInput = {
    type?: EnumSignupTypeFieldUpdateOperationsInput | $Enums.SignupType
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    saved?: BoolFieldUpdateOperationsInput | boolean
    note?: NullableStringFieldUpdateOperationsInput | string | null
    class?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSignupStatusFieldUpdateOperationsInput | $Enums.SignupStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    raid?: RaidUpdateOneRequiredWithoutSignupsNestedInput
    char?: BoosterCharUpdateOneWithoutSignupsNestedInput
    user?: UserUpdateOneWithoutSignupsNestedInput
  }

  export type SignupUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    raidId?: IntFieldUpdateOperationsInput | number
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumSignupTypeFieldUpdateOperationsInput | $Enums.SignupType
    charId?: NullableIntFieldUpdateOperationsInput | number | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    saved?: BoolFieldUpdateOperationsInput | boolean
    note?: NullableStringFieldUpdateOperationsInput | string | null
    class?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSignupStatusFieldUpdateOperationsInput | $Enums.SignupStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SignupCreateManyInput = {
    id?: number
    raidId: number
    userId?: string | null
    type: $Enums.SignupType
    charId?: number | null
    displayName?: string | null
    saved?: boolean
    note?: string | null
    class?: string | null
    status?: $Enums.SignupStatus
    createdAt?: Date | string
  }

  export type SignupUpdateManyMutationInput = {
    type?: EnumSignupTypeFieldUpdateOperationsInput | $Enums.SignupType
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    saved?: BoolFieldUpdateOperationsInput | boolean
    note?: NullableStringFieldUpdateOperationsInput | string | null
    class?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSignupStatusFieldUpdateOperationsInput | $Enums.SignupStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SignupUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    raidId?: IntFieldUpdateOperationsInput | number
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumSignupTypeFieldUpdateOperationsInput | $Enums.SignupType
    charId?: NullableIntFieldUpdateOperationsInput | number | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    saved?: BoolFieldUpdateOperationsInput | boolean
    note?: NullableStringFieldUpdateOperationsInput | string | null
    class?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSignupStatusFieldUpdateOperationsInput | $Enums.SignupStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type BoosterCharListRelationFilter = {
    every?: BoosterCharWhereInput
    some?: BoosterCharWhereInput
    none?: BoosterCharWhereInput
  }

  export type SignupListRelationFilter = {
    every?: SignupWhereInput
    some?: SignupWhereInput
    none?: SignupWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type BoosterCharOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SignupOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    discordId?: SortOrder
    username?: SortOrder
    displayName?: SortOrder
    avatarUrl?: SortOrder
    rolesCsv?: SortOrder
    isRaidlead?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    discordId?: SortOrder
    username?: SortOrder
    displayName?: SortOrder
    avatarUrl?: SortOrder
    rolesCsv?: SortOrder
    isRaidlead?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    discordId?: SortOrder
    username?: SortOrder
    displayName?: SortOrder
    avatarUrl?: SortOrder
    rolesCsv?: SortOrder
    isRaidlead?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type PresetNullableScalarRelationFilter = {
    is?: PresetWhereInput | null
    isNot?: PresetWhereInput | null
  }

  export type RaidCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    difficulty?: SortOrder
    lootType?: SortOrder
    date?: SortOrder
    lead?: SortOrder
    bosses?: SortOrder
    tanks?: SortOrder
    healers?: SortOrder
    dps?: SortOrder
    lootbuddies?: SortOrder
    channelId?: SortOrder
    messageId?: SortOrder
    presetId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RaidAvgOrderByAggregateInput = {
    id?: SortOrder
    bosses?: SortOrder
    tanks?: SortOrder
    healers?: SortOrder
    dps?: SortOrder
    lootbuddies?: SortOrder
    presetId?: SortOrder
  }

  export type RaidMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    difficulty?: SortOrder
    lootType?: SortOrder
    date?: SortOrder
    lead?: SortOrder
    bosses?: SortOrder
    tanks?: SortOrder
    healers?: SortOrder
    dps?: SortOrder
    lootbuddies?: SortOrder
    channelId?: SortOrder
    messageId?: SortOrder
    presetId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RaidMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    difficulty?: SortOrder
    lootType?: SortOrder
    date?: SortOrder
    lead?: SortOrder
    bosses?: SortOrder
    tanks?: SortOrder
    healers?: SortOrder
    dps?: SortOrder
    lootbuddies?: SortOrder
    channelId?: SortOrder
    messageId?: SortOrder
    presetId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RaidSumOrderByAggregateInput = {
    id?: SortOrder
    bosses?: SortOrder
    tanks?: SortOrder
    healers?: SortOrder
    dps?: SortOrder
    lootbuddies?: SortOrder
    presetId?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type RaidListRelationFilter = {
    every?: RaidWhereInput
    some?: RaidWhereInput
    none?: RaidWhereInput
  }

  export type RaidOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PresetCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    tanks?: SortOrder
    healers?: SortOrder
    dps?: SortOrder
    lootbuddies?: SortOrder
  }

  export type PresetAvgOrderByAggregateInput = {
    id?: SortOrder
    tanks?: SortOrder
    healers?: SortOrder
    dps?: SortOrder
    lootbuddies?: SortOrder
  }

  export type PresetMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    tanks?: SortOrder
    healers?: SortOrder
    dps?: SortOrder
    lootbuddies?: SortOrder
  }

  export type PresetMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    tanks?: SortOrder
    healers?: SortOrder
    dps?: SortOrder
    lootbuddies?: SortOrder
  }

  export type PresetSumOrderByAggregateInput = {
    id?: SortOrder
    tanks?: SortOrder
    healers?: SortOrder
    dps?: SortOrder
    lootbuddies?: SortOrder
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type BoosterCharCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    realm?: SortOrder
    class?: SortOrder
    spec?: SortOrder
    rioScore?: SortOrder
    progress?: SortOrder
    itemLevel?: SortOrder
    wclUrl?: SortOrder
    updatedAt?: SortOrder
  }

  export type BoosterCharAvgOrderByAggregateInput = {
    id?: SortOrder
    rioScore?: SortOrder
    itemLevel?: SortOrder
  }

  export type BoosterCharMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    realm?: SortOrder
    class?: SortOrder
    spec?: SortOrder
    rioScore?: SortOrder
    progress?: SortOrder
    itemLevel?: SortOrder
    wclUrl?: SortOrder
    updatedAt?: SortOrder
  }

  export type BoosterCharMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    realm?: SortOrder
    class?: SortOrder
    spec?: SortOrder
    rioScore?: SortOrder
    progress?: SortOrder
    itemLevel?: SortOrder
    wclUrl?: SortOrder
    updatedAt?: SortOrder
  }

  export type BoosterCharSumOrderByAggregateInput = {
    id?: SortOrder
    rioScore?: SortOrder
    itemLevel?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type EnumSignupTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.SignupType | EnumSignupTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SignupType[]
    notIn?: $Enums.SignupType[]
    not?: NestedEnumSignupTypeFilter<$PrismaModel> | $Enums.SignupType
  }

  export type EnumSignupStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SignupStatus | EnumSignupStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SignupStatus[]
    notIn?: $Enums.SignupStatus[]
    not?: NestedEnumSignupStatusFilter<$PrismaModel> | $Enums.SignupStatus
  }

  export type RaidScalarRelationFilter = {
    is?: RaidWhereInput
    isNot?: RaidWhereInput
  }

  export type BoosterCharNullableScalarRelationFilter = {
    is?: BoosterCharWhereInput | null
    isNot?: BoosterCharWhereInput | null
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type SignupCountOrderByAggregateInput = {
    id?: SortOrder
    raidId?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    charId?: SortOrder
    displayName?: SortOrder
    saved?: SortOrder
    note?: SortOrder
    class?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type SignupAvgOrderByAggregateInput = {
    id?: SortOrder
    raidId?: SortOrder
    charId?: SortOrder
  }

  export type SignupMaxOrderByAggregateInput = {
    id?: SortOrder
    raidId?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    charId?: SortOrder
    displayName?: SortOrder
    saved?: SortOrder
    note?: SortOrder
    class?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type SignupMinOrderByAggregateInput = {
    id?: SortOrder
    raidId?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    charId?: SortOrder
    displayName?: SortOrder
    saved?: SortOrder
    note?: SortOrder
    class?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type SignupSumOrderByAggregateInput = {
    id?: SortOrder
    raidId?: SortOrder
    charId?: SortOrder
  }

  export type EnumSignupTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SignupType | EnumSignupTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SignupType[]
    notIn?: $Enums.SignupType[]
    not?: NestedEnumSignupTypeWithAggregatesFilter<$PrismaModel> | $Enums.SignupType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSignupTypeFilter<$PrismaModel>
    _max?: NestedEnumSignupTypeFilter<$PrismaModel>
  }

  export type EnumSignupStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SignupStatus | EnumSignupStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SignupStatus[]
    notIn?: $Enums.SignupStatus[]
    not?: NestedEnumSignupStatusWithAggregatesFilter<$PrismaModel> | $Enums.SignupStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSignupStatusFilter<$PrismaModel>
    _max?: NestedEnumSignupStatusFilter<$PrismaModel>
  }

  export type BoosterCharCreateNestedManyWithoutUserInput = {
    create?: XOR<BoosterCharCreateWithoutUserInput, BoosterCharUncheckedCreateWithoutUserInput> | BoosterCharCreateWithoutUserInput[] | BoosterCharUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BoosterCharCreateOrConnectWithoutUserInput | BoosterCharCreateOrConnectWithoutUserInput[]
    createMany?: BoosterCharCreateManyUserInputEnvelope
    connect?: BoosterCharWhereUniqueInput | BoosterCharWhereUniqueInput[]
  }

  export type SignupCreateNestedManyWithoutUserInput = {
    create?: XOR<SignupCreateWithoutUserInput, SignupUncheckedCreateWithoutUserInput> | SignupCreateWithoutUserInput[] | SignupUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SignupCreateOrConnectWithoutUserInput | SignupCreateOrConnectWithoutUserInput[]
    createMany?: SignupCreateManyUserInputEnvelope
    connect?: SignupWhereUniqueInput | SignupWhereUniqueInput[]
  }

  export type BoosterCharUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<BoosterCharCreateWithoutUserInput, BoosterCharUncheckedCreateWithoutUserInput> | BoosterCharCreateWithoutUserInput[] | BoosterCharUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BoosterCharCreateOrConnectWithoutUserInput | BoosterCharCreateOrConnectWithoutUserInput[]
    createMany?: BoosterCharCreateManyUserInputEnvelope
    connect?: BoosterCharWhereUniqueInput | BoosterCharWhereUniqueInput[]
  }

  export type SignupUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SignupCreateWithoutUserInput, SignupUncheckedCreateWithoutUserInput> | SignupCreateWithoutUserInput[] | SignupUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SignupCreateOrConnectWithoutUserInput | SignupCreateOrConnectWithoutUserInput[]
    createMany?: SignupCreateManyUserInputEnvelope
    connect?: SignupWhereUniqueInput | SignupWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type BoosterCharUpdateManyWithoutUserNestedInput = {
    create?: XOR<BoosterCharCreateWithoutUserInput, BoosterCharUncheckedCreateWithoutUserInput> | BoosterCharCreateWithoutUserInput[] | BoosterCharUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BoosterCharCreateOrConnectWithoutUserInput | BoosterCharCreateOrConnectWithoutUserInput[]
    upsert?: BoosterCharUpsertWithWhereUniqueWithoutUserInput | BoosterCharUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BoosterCharCreateManyUserInputEnvelope
    set?: BoosterCharWhereUniqueInput | BoosterCharWhereUniqueInput[]
    disconnect?: BoosterCharWhereUniqueInput | BoosterCharWhereUniqueInput[]
    delete?: BoosterCharWhereUniqueInput | BoosterCharWhereUniqueInput[]
    connect?: BoosterCharWhereUniqueInput | BoosterCharWhereUniqueInput[]
    update?: BoosterCharUpdateWithWhereUniqueWithoutUserInput | BoosterCharUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BoosterCharUpdateManyWithWhereWithoutUserInput | BoosterCharUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BoosterCharScalarWhereInput | BoosterCharScalarWhereInput[]
  }

  export type SignupUpdateManyWithoutUserNestedInput = {
    create?: XOR<SignupCreateWithoutUserInput, SignupUncheckedCreateWithoutUserInput> | SignupCreateWithoutUserInput[] | SignupUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SignupCreateOrConnectWithoutUserInput | SignupCreateOrConnectWithoutUserInput[]
    upsert?: SignupUpsertWithWhereUniqueWithoutUserInput | SignupUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SignupCreateManyUserInputEnvelope
    set?: SignupWhereUniqueInput | SignupWhereUniqueInput[]
    disconnect?: SignupWhereUniqueInput | SignupWhereUniqueInput[]
    delete?: SignupWhereUniqueInput | SignupWhereUniqueInput[]
    connect?: SignupWhereUniqueInput | SignupWhereUniqueInput[]
    update?: SignupUpdateWithWhereUniqueWithoutUserInput | SignupUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SignupUpdateManyWithWhereWithoutUserInput | SignupUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SignupScalarWhereInput | SignupScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type BoosterCharUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<BoosterCharCreateWithoutUserInput, BoosterCharUncheckedCreateWithoutUserInput> | BoosterCharCreateWithoutUserInput[] | BoosterCharUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BoosterCharCreateOrConnectWithoutUserInput | BoosterCharCreateOrConnectWithoutUserInput[]
    upsert?: BoosterCharUpsertWithWhereUniqueWithoutUserInput | BoosterCharUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BoosterCharCreateManyUserInputEnvelope
    set?: BoosterCharWhereUniqueInput | BoosterCharWhereUniqueInput[]
    disconnect?: BoosterCharWhereUniqueInput | BoosterCharWhereUniqueInput[]
    delete?: BoosterCharWhereUniqueInput | BoosterCharWhereUniqueInput[]
    connect?: BoosterCharWhereUniqueInput | BoosterCharWhereUniqueInput[]
    update?: BoosterCharUpdateWithWhereUniqueWithoutUserInput | BoosterCharUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BoosterCharUpdateManyWithWhereWithoutUserInput | BoosterCharUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BoosterCharScalarWhereInput | BoosterCharScalarWhereInput[]
  }

  export type SignupUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SignupCreateWithoutUserInput, SignupUncheckedCreateWithoutUserInput> | SignupCreateWithoutUserInput[] | SignupUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SignupCreateOrConnectWithoutUserInput | SignupCreateOrConnectWithoutUserInput[]
    upsert?: SignupUpsertWithWhereUniqueWithoutUserInput | SignupUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SignupCreateManyUserInputEnvelope
    set?: SignupWhereUniqueInput | SignupWhereUniqueInput[]
    disconnect?: SignupWhereUniqueInput | SignupWhereUniqueInput[]
    delete?: SignupWhereUniqueInput | SignupWhereUniqueInput[]
    connect?: SignupWhereUniqueInput | SignupWhereUniqueInput[]
    update?: SignupUpdateWithWhereUniqueWithoutUserInput | SignupUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SignupUpdateManyWithWhereWithoutUserInput | SignupUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SignupScalarWhereInput | SignupScalarWhereInput[]
  }

  export type PresetCreateNestedOneWithoutRaidsInput = {
    create?: XOR<PresetCreateWithoutRaidsInput, PresetUncheckedCreateWithoutRaidsInput>
    connectOrCreate?: PresetCreateOrConnectWithoutRaidsInput
    connect?: PresetWhereUniqueInput
  }

  export type SignupCreateNestedManyWithoutRaidInput = {
    create?: XOR<SignupCreateWithoutRaidInput, SignupUncheckedCreateWithoutRaidInput> | SignupCreateWithoutRaidInput[] | SignupUncheckedCreateWithoutRaidInput[]
    connectOrCreate?: SignupCreateOrConnectWithoutRaidInput | SignupCreateOrConnectWithoutRaidInput[]
    createMany?: SignupCreateManyRaidInputEnvelope
    connect?: SignupWhereUniqueInput | SignupWhereUniqueInput[]
  }

  export type SignupUncheckedCreateNestedManyWithoutRaidInput = {
    create?: XOR<SignupCreateWithoutRaidInput, SignupUncheckedCreateWithoutRaidInput> | SignupCreateWithoutRaidInput[] | SignupUncheckedCreateWithoutRaidInput[]
    connectOrCreate?: SignupCreateOrConnectWithoutRaidInput | SignupCreateOrConnectWithoutRaidInput[]
    createMany?: SignupCreateManyRaidInputEnvelope
    connect?: SignupWhereUniqueInput | SignupWhereUniqueInput[]
  }

  export type PresetUpdateOneWithoutRaidsNestedInput = {
    create?: XOR<PresetCreateWithoutRaidsInput, PresetUncheckedCreateWithoutRaidsInput>
    connectOrCreate?: PresetCreateOrConnectWithoutRaidsInput
    upsert?: PresetUpsertWithoutRaidsInput
    disconnect?: PresetWhereInput | boolean
    delete?: PresetWhereInput | boolean
    connect?: PresetWhereUniqueInput
    update?: XOR<XOR<PresetUpdateToOneWithWhereWithoutRaidsInput, PresetUpdateWithoutRaidsInput>, PresetUncheckedUpdateWithoutRaidsInput>
  }

  export type SignupUpdateManyWithoutRaidNestedInput = {
    create?: XOR<SignupCreateWithoutRaidInput, SignupUncheckedCreateWithoutRaidInput> | SignupCreateWithoutRaidInput[] | SignupUncheckedCreateWithoutRaidInput[]
    connectOrCreate?: SignupCreateOrConnectWithoutRaidInput | SignupCreateOrConnectWithoutRaidInput[]
    upsert?: SignupUpsertWithWhereUniqueWithoutRaidInput | SignupUpsertWithWhereUniqueWithoutRaidInput[]
    createMany?: SignupCreateManyRaidInputEnvelope
    set?: SignupWhereUniqueInput | SignupWhereUniqueInput[]
    disconnect?: SignupWhereUniqueInput | SignupWhereUniqueInput[]
    delete?: SignupWhereUniqueInput | SignupWhereUniqueInput[]
    connect?: SignupWhereUniqueInput | SignupWhereUniqueInput[]
    update?: SignupUpdateWithWhereUniqueWithoutRaidInput | SignupUpdateWithWhereUniqueWithoutRaidInput[]
    updateMany?: SignupUpdateManyWithWhereWithoutRaidInput | SignupUpdateManyWithWhereWithoutRaidInput[]
    deleteMany?: SignupScalarWhereInput | SignupScalarWhereInput[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type SignupUncheckedUpdateManyWithoutRaidNestedInput = {
    create?: XOR<SignupCreateWithoutRaidInput, SignupUncheckedCreateWithoutRaidInput> | SignupCreateWithoutRaidInput[] | SignupUncheckedCreateWithoutRaidInput[]
    connectOrCreate?: SignupCreateOrConnectWithoutRaidInput | SignupCreateOrConnectWithoutRaidInput[]
    upsert?: SignupUpsertWithWhereUniqueWithoutRaidInput | SignupUpsertWithWhereUniqueWithoutRaidInput[]
    createMany?: SignupCreateManyRaidInputEnvelope
    set?: SignupWhereUniqueInput | SignupWhereUniqueInput[]
    disconnect?: SignupWhereUniqueInput | SignupWhereUniqueInput[]
    delete?: SignupWhereUniqueInput | SignupWhereUniqueInput[]
    connect?: SignupWhereUniqueInput | SignupWhereUniqueInput[]
    update?: SignupUpdateWithWhereUniqueWithoutRaidInput | SignupUpdateWithWhereUniqueWithoutRaidInput[]
    updateMany?: SignupUpdateManyWithWhereWithoutRaidInput | SignupUpdateManyWithWhereWithoutRaidInput[]
    deleteMany?: SignupScalarWhereInput | SignupScalarWhereInput[]
  }

  export type RaidCreateNestedManyWithoutPresetInput = {
    create?: XOR<RaidCreateWithoutPresetInput, RaidUncheckedCreateWithoutPresetInput> | RaidCreateWithoutPresetInput[] | RaidUncheckedCreateWithoutPresetInput[]
    connectOrCreate?: RaidCreateOrConnectWithoutPresetInput | RaidCreateOrConnectWithoutPresetInput[]
    createMany?: RaidCreateManyPresetInputEnvelope
    connect?: RaidWhereUniqueInput | RaidWhereUniqueInput[]
  }

  export type RaidUncheckedCreateNestedManyWithoutPresetInput = {
    create?: XOR<RaidCreateWithoutPresetInput, RaidUncheckedCreateWithoutPresetInput> | RaidCreateWithoutPresetInput[] | RaidUncheckedCreateWithoutPresetInput[]
    connectOrCreate?: RaidCreateOrConnectWithoutPresetInput | RaidCreateOrConnectWithoutPresetInput[]
    createMany?: RaidCreateManyPresetInputEnvelope
    connect?: RaidWhereUniqueInput | RaidWhereUniqueInput[]
  }

  export type RaidUpdateManyWithoutPresetNestedInput = {
    create?: XOR<RaidCreateWithoutPresetInput, RaidUncheckedCreateWithoutPresetInput> | RaidCreateWithoutPresetInput[] | RaidUncheckedCreateWithoutPresetInput[]
    connectOrCreate?: RaidCreateOrConnectWithoutPresetInput | RaidCreateOrConnectWithoutPresetInput[]
    upsert?: RaidUpsertWithWhereUniqueWithoutPresetInput | RaidUpsertWithWhereUniqueWithoutPresetInput[]
    createMany?: RaidCreateManyPresetInputEnvelope
    set?: RaidWhereUniqueInput | RaidWhereUniqueInput[]
    disconnect?: RaidWhereUniqueInput | RaidWhereUniqueInput[]
    delete?: RaidWhereUniqueInput | RaidWhereUniqueInput[]
    connect?: RaidWhereUniqueInput | RaidWhereUniqueInput[]
    update?: RaidUpdateWithWhereUniqueWithoutPresetInput | RaidUpdateWithWhereUniqueWithoutPresetInput[]
    updateMany?: RaidUpdateManyWithWhereWithoutPresetInput | RaidUpdateManyWithWhereWithoutPresetInput[]
    deleteMany?: RaidScalarWhereInput | RaidScalarWhereInput[]
  }

  export type RaidUncheckedUpdateManyWithoutPresetNestedInput = {
    create?: XOR<RaidCreateWithoutPresetInput, RaidUncheckedCreateWithoutPresetInput> | RaidCreateWithoutPresetInput[] | RaidUncheckedCreateWithoutPresetInput[]
    connectOrCreate?: RaidCreateOrConnectWithoutPresetInput | RaidCreateOrConnectWithoutPresetInput[]
    upsert?: RaidUpsertWithWhereUniqueWithoutPresetInput | RaidUpsertWithWhereUniqueWithoutPresetInput[]
    createMany?: RaidCreateManyPresetInputEnvelope
    set?: RaidWhereUniqueInput | RaidWhereUniqueInput[]
    disconnect?: RaidWhereUniqueInput | RaidWhereUniqueInput[]
    delete?: RaidWhereUniqueInput | RaidWhereUniqueInput[]
    connect?: RaidWhereUniqueInput | RaidWhereUniqueInput[]
    update?: RaidUpdateWithWhereUniqueWithoutPresetInput | RaidUpdateWithWhereUniqueWithoutPresetInput[]
    updateMany?: RaidUpdateManyWithWhereWithoutPresetInput | RaidUpdateManyWithWhereWithoutPresetInput[]
    deleteMany?: RaidScalarWhereInput | RaidScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutCharsInput = {
    create?: XOR<UserCreateWithoutCharsInput, UserUncheckedCreateWithoutCharsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCharsInput
    connect?: UserWhereUniqueInput
  }

  export type SignupCreateNestedManyWithoutCharInput = {
    create?: XOR<SignupCreateWithoutCharInput, SignupUncheckedCreateWithoutCharInput> | SignupCreateWithoutCharInput[] | SignupUncheckedCreateWithoutCharInput[]
    connectOrCreate?: SignupCreateOrConnectWithoutCharInput | SignupCreateOrConnectWithoutCharInput[]
    createMany?: SignupCreateManyCharInputEnvelope
    connect?: SignupWhereUniqueInput | SignupWhereUniqueInput[]
  }

  export type SignupUncheckedCreateNestedManyWithoutCharInput = {
    create?: XOR<SignupCreateWithoutCharInput, SignupUncheckedCreateWithoutCharInput> | SignupCreateWithoutCharInput[] | SignupUncheckedCreateWithoutCharInput[]
    connectOrCreate?: SignupCreateOrConnectWithoutCharInput | SignupCreateOrConnectWithoutCharInput[]
    createMany?: SignupCreateManyCharInputEnvelope
    connect?: SignupWhereUniqueInput | SignupWhereUniqueInput[]
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutCharsNestedInput = {
    create?: XOR<UserCreateWithoutCharsInput, UserUncheckedCreateWithoutCharsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCharsInput
    upsert?: UserUpsertWithoutCharsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCharsInput, UserUpdateWithoutCharsInput>, UserUncheckedUpdateWithoutCharsInput>
  }

  export type SignupUpdateManyWithoutCharNestedInput = {
    create?: XOR<SignupCreateWithoutCharInput, SignupUncheckedCreateWithoutCharInput> | SignupCreateWithoutCharInput[] | SignupUncheckedCreateWithoutCharInput[]
    connectOrCreate?: SignupCreateOrConnectWithoutCharInput | SignupCreateOrConnectWithoutCharInput[]
    upsert?: SignupUpsertWithWhereUniqueWithoutCharInput | SignupUpsertWithWhereUniqueWithoutCharInput[]
    createMany?: SignupCreateManyCharInputEnvelope
    set?: SignupWhereUniqueInput | SignupWhereUniqueInput[]
    disconnect?: SignupWhereUniqueInput | SignupWhereUniqueInput[]
    delete?: SignupWhereUniqueInput | SignupWhereUniqueInput[]
    connect?: SignupWhereUniqueInput | SignupWhereUniqueInput[]
    update?: SignupUpdateWithWhereUniqueWithoutCharInput | SignupUpdateWithWhereUniqueWithoutCharInput[]
    updateMany?: SignupUpdateManyWithWhereWithoutCharInput | SignupUpdateManyWithWhereWithoutCharInput[]
    deleteMany?: SignupScalarWhereInput | SignupScalarWhereInput[]
  }

  export type SignupUncheckedUpdateManyWithoutCharNestedInput = {
    create?: XOR<SignupCreateWithoutCharInput, SignupUncheckedCreateWithoutCharInput> | SignupCreateWithoutCharInput[] | SignupUncheckedCreateWithoutCharInput[]
    connectOrCreate?: SignupCreateOrConnectWithoutCharInput | SignupCreateOrConnectWithoutCharInput[]
    upsert?: SignupUpsertWithWhereUniqueWithoutCharInput | SignupUpsertWithWhereUniqueWithoutCharInput[]
    createMany?: SignupCreateManyCharInputEnvelope
    set?: SignupWhereUniqueInput | SignupWhereUniqueInput[]
    disconnect?: SignupWhereUniqueInput | SignupWhereUniqueInput[]
    delete?: SignupWhereUniqueInput | SignupWhereUniqueInput[]
    connect?: SignupWhereUniqueInput | SignupWhereUniqueInput[]
    update?: SignupUpdateWithWhereUniqueWithoutCharInput | SignupUpdateWithWhereUniqueWithoutCharInput[]
    updateMany?: SignupUpdateManyWithWhereWithoutCharInput | SignupUpdateManyWithWhereWithoutCharInput[]
    deleteMany?: SignupScalarWhereInput | SignupScalarWhereInput[]
  }

  export type RaidCreateNestedOneWithoutSignupsInput = {
    create?: XOR<RaidCreateWithoutSignupsInput, RaidUncheckedCreateWithoutSignupsInput>
    connectOrCreate?: RaidCreateOrConnectWithoutSignupsInput
    connect?: RaidWhereUniqueInput
  }

  export type BoosterCharCreateNestedOneWithoutSignupsInput = {
    create?: XOR<BoosterCharCreateWithoutSignupsInput, BoosterCharUncheckedCreateWithoutSignupsInput>
    connectOrCreate?: BoosterCharCreateOrConnectWithoutSignupsInput
    connect?: BoosterCharWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutSignupsInput = {
    create?: XOR<UserCreateWithoutSignupsInput, UserUncheckedCreateWithoutSignupsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSignupsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumSignupTypeFieldUpdateOperationsInput = {
    set?: $Enums.SignupType
  }

  export type EnumSignupStatusFieldUpdateOperationsInput = {
    set?: $Enums.SignupStatus
  }

  export type RaidUpdateOneRequiredWithoutSignupsNestedInput = {
    create?: XOR<RaidCreateWithoutSignupsInput, RaidUncheckedCreateWithoutSignupsInput>
    connectOrCreate?: RaidCreateOrConnectWithoutSignupsInput
    upsert?: RaidUpsertWithoutSignupsInput
    connect?: RaidWhereUniqueInput
    update?: XOR<XOR<RaidUpdateToOneWithWhereWithoutSignupsInput, RaidUpdateWithoutSignupsInput>, RaidUncheckedUpdateWithoutSignupsInput>
  }

  export type BoosterCharUpdateOneWithoutSignupsNestedInput = {
    create?: XOR<BoosterCharCreateWithoutSignupsInput, BoosterCharUncheckedCreateWithoutSignupsInput>
    connectOrCreate?: BoosterCharCreateOrConnectWithoutSignupsInput
    upsert?: BoosterCharUpsertWithoutSignupsInput
    disconnect?: BoosterCharWhereInput | boolean
    delete?: BoosterCharWhereInput | boolean
    connect?: BoosterCharWhereUniqueInput
    update?: XOR<XOR<BoosterCharUpdateToOneWithWhereWithoutSignupsInput, BoosterCharUpdateWithoutSignupsInput>, BoosterCharUncheckedUpdateWithoutSignupsInput>
  }

  export type UserUpdateOneWithoutSignupsNestedInput = {
    create?: XOR<UserCreateWithoutSignupsInput, UserUncheckedCreateWithoutSignupsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSignupsInput
    upsert?: UserUpsertWithoutSignupsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSignupsInput, UserUpdateWithoutSignupsInput>, UserUncheckedUpdateWithoutSignupsInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedEnumSignupTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.SignupType | EnumSignupTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SignupType[]
    notIn?: $Enums.SignupType[]
    not?: NestedEnumSignupTypeFilter<$PrismaModel> | $Enums.SignupType
  }

  export type NestedEnumSignupStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SignupStatus | EnumSignupStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SignupStatus[]
    notIn?: $Enums.SignupStatus[]
    not?: NestedEnumSignupStatusFilter<$PrismaModel> | $Enums.SignupStatus
  }

  export type NestedEnumSignupTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SignupType | EnumSignupTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SignupType[]
    notIn?: $Enums.SignupType[]
    not?: NestedEnumSignupTypeWithAggregatesFilter<$PrismaModel> | $Enums.SignupType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSignupTypeFilter<$PrismaModel>
    _max?: NestedEnumSignupTypeFilter<$PrismaModel>
  }

  export type NestedEnumSignupStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SignupStatus | EnumSignupStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SignupStatus[]
    notIn?: $Enums.SignupStatus[]
    not?: NestedEnumSignupStatusWithAggregatesFilter<$PrismaModel> | $Enums.SignupStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSignupStatusFilter<$PrismaModel>
    _max?: NestedEnumSignupStatusFilter<$PrismaModel>
  }

  export type BoosterCharCreateWithoutUserInput = {
    name: string
    realm: string
    class?: string | null
    spec?: string | null
    rioScore?: number | null
    progress?: string | null
    itemLevel?: number | null
    wclUrl?: string | null
    updatedAt?: Date | string
    signups?: SignupCreateNestedManyWithoutCharInput
  }

  export type BoosterCharUncheckedCreateWithoutUserInput = {
    id?: number
    name: string
    realm: string
    class?: string | null
    spec?: string | null
    rioScore?: number | null
    progress?: string | null
    itemLevel?: number | null
    wclUrl?: string | null
    updatedAt?: Date | string
    signups?: SignupUncheckedCreateNestedManyWithoutCharInput
  }

  export type BoosterCharCreateOrConnectWithoutUserInput = {
    where: BoosterCharWhereUniqueInput
    create: XOR<BoosterCharCreateWithoutUserInput, BoosterCharUncheckedCreateWithoutUserInput>
  }

  export type BoosterCharCreateManyUserInputEnvelope = {
    data: BoosterCharCreateManyUserInput | BoosterCharCreateManyUserInput[]
  }

  export type SignupCreateWithoutUserInput = {
    type: $Enums.SignupType
    displayName?: string | null
    saved?: boolean
    note?: string | null
    class?: string | null
    status?: $Enums.SignupStatus
    createdAt?: Date | string
    raid: RaidCreateNestedOneWithoutSignupsInput
    char?: BoosterCharCreateNestedOneWithoutSignupsInput
  }

  export type SignupUncheckedCreateWithoutUserInput = {
    id?: number
    raidId: number
    type: $Enums.SignupType
    charId?: number | null
    displayName?: string | null
    saved?: boolean
    note?: string | null
    class?: string | null
    status?: $Enums.SignupStatus
    createdAt?: Date | string
  }

  export type SignupCreateOrConnectWithoutUserInput = {
    where: SignupWhereUniqueInput
    create: XOR<SignupCreateWithoutUserInput, SignupUncheckedCreateWithoutUserInput>
  }

  export type SignupCreateManyUserInputEnvelope = {
    data: SignupCreateManyUserInput | SignupCreateManyUserInput[]
  }

  export type BoosterCharUpsertWithWhereUniqueWithoutUserInput = {
    where: BoosterCharWhereUniqueInput
    update: XOR<BoosterCharUpdateWithoutUserInput, BoosterCharUncheckedUpdateWithoutUserInput>
    create: XOR<BoosterCharCreateWithoutUserInput, BoosterCharUncheckedCreateWithoutUserInput>
  }

  export type BoosterCharUpdateWithWhereUniqueWithoutUserInput = {
    where: BoosterCharWhereUniqueInput
    data: XOR<BoosterCharUpdateWithoutUserInput, BoosterCharUncheckedUpdateWithoutUserInput>
  }

  export type BoosterCharUpdateManyWithWhereWithoutUserInput = {
    where: BoosterCharScalarWhereInput
    data: XOR<BoosterCharUpdateManyMutationInput, BoosterCharUncheckedUpdateManyWithoutUserInput>
  }

  export type BoosterCharScalarWhereInput = {
    AND?: BoosterCharScalarWhereInput | BoosterCharScalarWhereInput[]
    OR?: BoosterCharScalarWhereInput[]
    NOT?: BoosterCharScalarWhereInput | BoosterCharScalarWhereInput[]
    id?: IntFilter<"BoosterChar"> | number
    userId?: StringFilter<"BoosterChar"> | string
    name?: StringFilter<"BoosterChar"> | string
    realm?: StringFilter<"BoosterChar"> | string
    class?: StringNullableFilter<"BoosterChar"> | string | null
    spec?: StringNullableFilter<"BoosterChar"> | string | null
    rioScore?: FloatNullableFilter<"BoosterChar"> | number | null
    progress?: StringNullableFilter<"BoosterChar"> | string | null
    itemLevel?: IntNullableFilter<"BoosterChar"> | number | null
    wclUrl?: StringNullableFilter<"BoosterChar"> | string | null
    updatedAt?: DateTimeFilter<"BoosterChar"> | Date | string
  }

  export type SignupUpsertWithWhereUniqueWithoutUserInput = {
    where: SignupWhereUniqueInput
    update: XOR<SignupUpdateWithoutUserInput, SignupUncheckedUpdateWithoutUserInput>
    create: XOR<SignupCreateWithoutUserInput, SignupUncheckedCreateWithoutUserInput>
  }

  export type SignupUpdateWithWhereUniqueWithoutUserInput = {
    where: SignupWhereUniqueInput
    data: XOR<SignupUpdateWithoutUserInput, SignupUncheckedUpdateWithoutUserInput>
  }

  export type SignupUpdateManyWithWhereWithoutUserInput = {
    where: SignupScalarWhereInput
    data: XOR<SignupUpdateManyMutationInput, SignupUncheckedUpdateManyWithoutUserInput>
  }

  export type SignupScalarWhereInput = {
    AND?: SignupScalarWhereInput | SignupScalarWhereInput[]
    OR?: SignupScalarWhereInput[]
    NOT?: SignupScalarWhereInput | SignupScalarWhereInput[]
    id?: IntFilter<"Signup"> | number
    raidId?: IntFilter<"Signup"> | number
    userId?: StringNullableFilter<"Signup"> | string | null
    type?: EnumSignupTypeFilter<"Signup"> | $Enums.SignupType
    charId?: IntNullableFilter<"Signup"> | number | null
    displayName?: StringNullableFilter<"Signup"> | string | null
    saved?: BoolFilter<"Signup"> | boolean
    note?: StringNullableFilter<"Signup"> | string | null
    class?: StringNullableFilter<"Signup"> | string | null
    status?: EnumSignupStatusFilter<"Signup"> | $Enums.SignupStatus
    createdAt?: DateTimeFilter<"Signup"> | Date | string
  }

  export type PresetCreateWithoutRaidsInput = {
    name: string
    tanks?: number
    healers?: number
    dps?: number
    lootbuddies?: number
  }

  export type PresetUncheckedCreateWithoutRaidsInput = {
    id?: number
    name: string
    tanks?: number
    healers?: number
    dps?: number
    lootbuddies?: number
  }

  export type PresetCreateOrConnectWithoutRaidsInput = {
    where: PresetWhereUniqueInput
    create: XOR<PresetCreateWithoutRaidsInput, PresetUncheckedCreateWithoutRaidsInput>
  }

  export type SignupCreateWithoutRaidInput = {
    type: $Enums.SignupType
    displayName?: string | null
    saved?: boolean
    note?: string | null
    class?: string | null
    status?: $Enums.SignupStatus
    createdAt?: Date | string
    char?: BoosterCharCreateNestedOneWithoutSignupsInput
    user?: UserCreateNestedOneWithoutSignupsInput
  }

  export type SignupUncheckedCreateWithoutRaidInput = {
    id?: number
    userId?: string | null
    type: $Enums.SignupType
    charId?: number | null
    displayName?: string | null
    saved?: boolean
    note?: string | null
    class?: string | null
    status?: $Enums.SignupStatus
    createdAt?: Date | string
  }

  export type SignupCreateOrConnectWithoutRaidInput = {
    where: SignupWhereUniqueInput
    create: XOR<SignupCreateWithoutRaidInput, SignupUncheckedCreateWithoutRaidInput>
  }

  export type SignupCreateManyRaidInputEnvelope = {
    data: SignupCreateManyRaidInput | SignupCreateManyRaidInput[]
  }

  export type PresetUpsertWithoutRaidsInput = {
    update: XOR<PresetUpdateWithoutRaidsInput, PresetUncheckedUpdateWithoutRaidsInput>
    create: XOR<PresetCreateWithoutRaidsInput, PresetUncheckedCreateWithoutRaidsInput>
    where?: PresetWhereInput
  }

  export type PresetUpdateToOneWithWhereWithoutRaidsInput = {
    where?: PresetWhereInput
    data: XOR<PresetUpdateWithoutRaidsInput, PresetUncheckedUpdateWithoutRaidsInput>
  }

  export type PresetUpdateWithoutRaidsInput = {
    name?: StringFieldUpdateOperationsInput | string
    tanks?: IntFieldUpdateOperationsInput | number
    healers?: IntFieldUpdateOperationsInput | number
    dps?: IntFieldUpdateOperationsInput | number
    lootbuddies?: IntFieldUpdateOperationsInput | number
  }

  export type PresetUncheckedUpdateWithoutRaidsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    tanks?: IntFieldUpdateOperationsInput | number
    healers?: IntFieldUpdateOperationsInput | number
    dps?: IntFieldUpdateOperationsInput | number
    lootbuddies?: IntFieldUpdateOperationsInput | number
  }

  export type SignupUpsertWithWhereUniqueWithoutRaidInput = {
    where: SignupWhereUniqueInput
    update: XOR<SignupUpdateWithoutRaidInput, SignupUncheckedUpdateWithoutRaidInput>
    create: XOR<SignupCreateWithoutRaidInput, SignupUncheckedCreateWithoutRaidInput>
  }

  export type SignupUpdateWithWhereUniqueWithoutRaidInput = {
    where: SignupWhereUniqueInput
    data: XOR<SignupUpdateWithoutRaidInput, SignupUncheckedUpdateWithoutRaidInput>
  }

  export type SignupUpdateManyWithWhereWithoutRaidInput = {
    where: SignupScalarWhereInput
    data: XOR<SignupUpdateManyMutationInput, SignupUncheckedUpdateManyWithoutRaidInput>
  }

  export type RaidCreateWithoutPresetInput = {
    title: string
    difficulty: string
    lootType: string
    date: Date | string
    lead?: string | null
    bosses: number
    tanks?: number
    healers?: number
    dps?: number
    lootbuddies?: number
    channelId?: string | null
    messageId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    signups?: SignupCreateNestedManyWithoutRaidInput
  }

  export type RaidUncheckedCreateWithoutPresetInput = {
    id?: number
    title: string
    difficulty: string
    lootType: string
    date: Date | string
    lead?: string | null
    bosses: number
    tanks?: number
    healers?: number
    dps?: number
    lootbuddies?: number
    channelId?: string | null
    messageId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    signups?: SignupUncheckedCreateNestedManyWithoutRaidInput
  }

  export type RaidCreateOrConnectWithoutPresetInput = {
    where: RaidWhereUniqueInput
    create: XOR<RaidCreateWithoutPresetInput, RaidUncheckedCreateWithoutPresetInput>
  }

  export type RaidCreateManyPresetInputEnvelope = {
    data: RaidCreateManyPresetInput | RaidCreateManyPresetInput[]
  }

  export type RaidUpsertWithWhereUniqueWithoutPresetInput = {
    where: RaidWhereUniqueInput
    update: XOR<RaidUpdateWithoutPresetInput, RaidUncheckedUpdateWithoutPresetInput>
    create: XOR<RaidCreateWithoutPresetInput, RaidUncheckedCreateWithoutPresetInput>
  }

  export type RaidUpdateWithWhereUniqueWithoutPresetInput = {
    where: RaidWhereUniqueInput
    data: XOR<RaidUpdateWithoutPresetInput, RaidUncheckedUpdateWithoutPresetInput>
  }

  export type RaidUpdateManyWithWhereWithoutPresetInput = {
    where: RaidScalarWhereInput
    data: XOR<RaidUpdateManyMutationInput, RaidUncheckedUpdateManyWithoutPresetInput>
  }

  export type RaidScalarWhereInput = {
    AND?: RaidScalarWhereInput | RaidScalarWhereInput[]
    OR?: RaidScalarWhereInput[]
    NOT?: RaidScalarWhereInput | RaidScalarWhereInput[]
    id?: IntFilter<"Raid"> | number
    title?: StringFilter<"Raid"> | string
    difficulty?: StringFilter<"Raid"> | string
    lootType?: StringFilter<"Raid"> | string
    date?: DateTimeFilter<"Raid"> | Date | string
    lead?: StringNullableFilter<"Raid"> | string | null
    bosses?: IntFilter<"Raid"> | number
    tanks?: IntFilter<"Raid"> | number
    healers?: IntFilter<"Raid"> | number
    dps?: IntFilter<"Raid"> | number
    lootbuddies?: IntFilter<"Raid"> | number
    channelId?: StringNullableFilter<"Raid"> | string | null
    messageId?: StringNullableFilter<"Raid"> | string | null
    presetId?: IntNullableFilter<"Raid"> | number | null
    createdAt?: DateTimeFilter<"Raid"> | Date | string
    updatedAt?: DateTimeFilter<"Raid"> | Date | string
  }

  export type UserCreateWithoutCharsInput = {
    discordId: string
    username?: string | null
    displayName?: string | null
    avatarUrl?: string | null
    rolesCsv?: string | null
    isRaidlead?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    signups?: SignupCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCharsInput = {
    id?: number
    discordId: string
    username?: string | null
    displayName?: string | null
    avatarUrl?: string | null
    rolesCsv?: string | null
    isRaidlead?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    signups?: SignupUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCharsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCharsInput, UserUncheckedCreateWithoutCharsInput>
  }

  export type SignupCreateWithoutCharInput = {
    type: $Enums.SignupType
    displayName?: string | null
    saved?: boolean
    note?: string | null
    class?: string | null
    status?: $Enums.SignupStatus
    createdAt?: Date | string
    raid: RaidCreateNestedOneWithoutSignupsInput
    user?: UserCreateNestedOneWithoutSignupsInput
  }

  export type SignupUncheckedCreateWithoutCharInput = {
    id?: number
    raidId: number
    userId?: string | null
    type: $Enums.SignupType
    displayName?: string | null
    saved?: boolean
    note?: string | null
    class?: string | null
    status?: $Enums.SignupStatus
    createdAt?: Date | string
  }

  export type SignupCreateOrConnectWithoutCharInput = {
    where: SignupWhereUniqueInput
    create: XOR<SignupCreateWithoutCharInput, SignupUncheckedCreateWithoutCharInput>
  }

  export type SignupCreateManyCharInputEnvelope = {
    data: SignupCreateManyCharInput | SignupCreateManyCharInput[]
  }

  export type UserUpsertWithoutCharsInput = {
    update: XOR<UserUpdateWithoutCharsInput, UserUncheckedUpdateWithoutCharsInput>
    create: XOR<UserCreateWithoutCharsInput, UserUncheckedCreateWithoutCharsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCharsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCharsInput, UserUncheckedUpdateWithoutCharsInput>
  }

  export type UserUpdateWithoutCharsInput = {
    discordId?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    rolesCsv?: NullableStringFieldUpdateOperationsInput | string | null
    isRaidlead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    signups?: SignupUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCharsInput = {
    id?: IntFieldUpdateOperationsInput | number
    discordId?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    rolesCsv?: NullableStringFieldUpdateOperationsInput | string | null
    isRaidlead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    signups?: SignupUncheckedUpdateManyWithoutUserNestedInput
  }

  export type SignupUpsertWithWhereUniqueWithoutCharInput = {
    where: SignupWhereUniqueInput
    update: XOR<SignupUpdateWithoutCharInput, SignupUncheckedUpdateWithoutCharInput>
    create: XOR<SignupCreateWithoutCharInput, SignupUncheckedCreateWithoutCharInput>
  }

  export type SignupUpdateWithWhereUniqueWithoutCharInput = {
    where: SignupWhereUniqueInput
    data: XOR<SignupUpdateWithoutCharInput, SignupUncheckedUpdateWithoutCharInput>
  }

  export type SignupUpdateManyWithWhereWithoutCharInput = {
    where: SignupScalarWhereInput
    data: XOR<SignupUpdateManyMutationInput, SignupUncheckedUpdateManyWithoutCharInput>
  }

  export type RaidCreateWithoutSignupsInput = {
    title: string
    difficulty: string
    lootType: string
    date: Date | string
    lead?: string | null
    bosses: number
    tanks?: number
    healers?: number
    dps?: number
    lootbuddies?: number
    channelId?: string | null
    messageId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    preset?: PresetCreateNestedOneWithoutRaidsInput
  }

  export type RaidUncheckedCreateWithoutSignupsInput = {
    id?: number
    title: string
    difficulty: string
    lootType: string
    date: Date | string
    lead?: string | null
    bosses: number
    tanks?: number
    healers?: number
    dps?: number
    lootbuddies?: number
    channelId?: string | null
    messageId?: string | null
    presetId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RaidCreateOrConnectWithoutSignupsInput = {
    where: RaidWhereUniqueInput
    create: XOR<RaidCreateWithoutSignupsInput, RaidUncheckedCreateWithoutSignupsInput>
  }

  export type BoosterCharCreateWithoutSignupsInput = {
    name: string
    realm: string
    class?: string | null
    spec?: string | null
    rioScore?: number | null
    progress?: string | null
    itemLevel?: number | null
    wclUrl?: string | null
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutCharsInput
  }

  export type BoosterCharUncheckedCreateWithoutSignupsInput = {
    id?: number
    userId: string
    name: string
    realm: string
    class?: string | null
    spec?: string | null
    rioScore?: number | null
    progress?: string | null
    itemLevel?: number | null
    wclUrl?: string | null
    updatedAt?: Date | string
  }

  export type BoosterCharCreateOrConnectWithoutSignupsInput = {
    where: BoosterCharWhereUniqueInput
    create: XOR<BoosterCharCreateWithoutSignupsInput, BoosterCharUncheckedCreateWithoutSignupsInput>
  }

  export type UserCreateWithoutSignupsInput = {
    discordId: string
    username?: string | null
    displayName?: string | null
    avatarUrl?: string | null
    rolesCsv?: string | null
    isRaidlead?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    chars?: BoosterCharCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSignupsInput = {
    id?: number
    discordId: string
    username?: string | null
    displayName?: string | null
    avatarUrl?: string | null
    rolesCsv?: string | null
    isRaidlead?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    chars?: BoosterCharUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSignupsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSignupsInput, UserUncheckedCreateWithoutSignupsInput>
  }

  export type RaidUpsertWithoutSignupsInput = {
    update: XOR<RaidUpdateWithoutSignupsInput, RaidUncheckedUpdateWithoutSignupsInput>
    create: XOR<RaidCreateWithoutSignupsInput, RaidUncheckedCreateWithoutSignupsInput>
    where?: RaidWhereInput
  }

  export type RaidUpdateToOneWithWhereWithoutSignupsInput = {
    where?: RaidWhereInput
    data: XOR<RaidUpdateWithoutSignupsInput, RaidUncheckedUpdateWithoutSignupsInput>
  }

  export type RaidUpdateWithoutSignupsInput = {
    title?: StringFieldUpdateOperationsInput | string
    difficulty?: StringFieldUpdateOperationsInput | string
    lootType?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    lead?: NullableStringFieldUpdateOperationsInput | string | null
    bosses?: IntFieldUpdateOperationsInput | number
    tanks?: IntFieldUpdateOperationsInput | number
    healers?: IntFieldUpdateOperationsInput | number
    dps?: IntFieldUpdateOperationsInput | number
    lootbuddies?: IntFieldUpdateOperationsInput | number
    channelId?: NullableStringFieldUpdateOperationsInput | string | null
    messageId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    preset?: PresetUpdateOneWithoutRaidsNestedInput
  }

  export type RaidUncheckedUpdateWithoutSignupsInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    difficulty?: StringFieldUpdateOperationsInput | string
    lootType?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    lead?: NullableStringFieldUpdateOperationsInput | string | null
    bosses?: IntFieldUpdateOperationsInput | number
    tanks?: IntFieldUpdateOperationsInput | number
    healers?: IntFieldUpdateOperationsInput | number
    dps?: IntFieldUpdateOperationsInput | number
    lootbuddies?: IntFieldUpdateOperationsInput | number
    channelId?: NullableStringFieldUpdateOperationsInput | string | null
    messageId?: NullableStringFieldUpdateOperationsInput | string | null
    presetId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BoosterCharUpsertWithoutSignupsInput = {
    update: XOR<BoosterCharUpdateWithoutSignupsInput, BoosterCharUncheckedUpdateWithoutSignupsInput>
    create: XOR<BoosterCharCreateWithoutSignupsInput, BoosterCharUncheckedCreateWithoutSignupsInput>
    where?: BoosterCharWhereInput
  }

  export type BoosterCharUpdateToOneWithWhereWithoutSignupsInput = {
    where?: BoosterCharWhereInput
    data: XOR<BoosterCharUpdateWithoutSignupsInput, BoosterCharUncheckedUpdateWithoutSignupsInput>
  }

  export type BoosterCharUpdateWithoutSignupsInput = {
    name?: StringFieldUpdateOperationsInput | string
    realm?: StringFieldUpdateOperationsInput | string
    class?: NullableStringFieldUpdateOperationsInput | string | null
    spec?: NullableStringFieldUpdateOperationsInput | string | null
    rioScore?: NullableFloatFieldUpdateOperationsInput | number | null
    progress?: NullableStringFieldUpdateOperationsInput | string | null
    itemLevel?: NullableIntFieldUpdateOperationsInput | number | null
    wclUrl?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCharsNestedInput
  }

  export type BoosterCharUncheckedUpdateWithoutSignupsInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    realm?: StringFieldUpdateOperationsInput | string
    class?: NullableStringFieldUpdateOperationsInput | string | null
    spec?: NullableStringFieldUpdateOperationsInput | string | null
    rioScore?: NullableFloatFieldUpdateOperationsInput | number | null
    progress?: NullableStringFieldUpdateOperationsInput | string | null
    itemLevel?: NullableIntFieldUpdateOperationsInput | number | null
    wclUrl?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutSignupsInput = {
    update: XOR<UserUpdateWithoutSignupsInput, UserUncheckedUpdateWithoutSignupsInput>
    create: XOR<UserCreateWithoutSignupsInput, UserUncheckedCreateWithoutSignupsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSignupsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSignupsInput, UserUncheckedUpdateWithoutSignupsInput>
  }

  export type UserUpdateWithoutSignupsInput = {
    discordId?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    rolesCsv?: NullableStringFieldUpdateOperationsInput | string | null
    isRaidlead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chars?: BoosterCharUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSignupsInput = {
    id?: IntFieldUpdateOperationsInput | number
    discordId?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    rolesCsv?: NullableStringFieldUpdateOperationsInput | string | null
    isRaidlead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chars?: BoosterCharUncheckedUpdateManyWithoutUserNestedInput
  }

  export type BoosterCharCreateManyUserInput = {
    id?: number
    name: string
    realm: string
    class?: string | null
    spec?: string | null
    rioScore?: number | null
    progress?: string | null
    itemLevel?: number | null
    wclUrl?: string | null
    updatedAt?: Date | string
  }

  export type SignupCreateManyUserInput = {
    id?: number
    raidId: number
    type: $Enums.SignupType
    charId?: number | null
    displayName?: string | null
    saved?: boolean
    note?: string | null
    class?: string | null
    status?: $Enums.SignupStatus
    createdAt?: Date | string
  }

  export type BoosterCharUpdateWithoutUserInput = {
    name?: StringFieldUpdateOperationsInput | string
    realm?: StringFieldUpdateOperationsInput | string
    class?: NullableStringFieldUpdateOperationsInput | string | null
    spec?: NullableStringFieldUpdateOperationsInput | string | null
    rioScore?: NullableFloatFieldUpdateOperationsInput | number | null
    progress?: NullableStringFieldUpdateOperationsInput | string | null
    itemLevel?: NullableIntFieldUpdateOperationsInput | number | null
    wclUrl?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    signups?: SignupUpdateManyWithoutCharNestedInput
  }

  export type BoosterCharUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    realm?: StringFieldUpdateOperationsInput | string
    class?: NullableStringFieldUpdateOperationsInput | string | null
    spec?: NullableStringFieldUpdateOperationsInput | string | null
    rioScore?: NullableFloatFieldUpdateOperationsInput | number | null
    progress?: NullableStringFieldUpdateOperationsInput | string | null
    itemLevel?: NullableIntFieldUpdateOperationsInput | number | null
    wclUrl?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    signups?: SignupUncheckedUpdateManyWithoutCharNestedInput
  }

  export type BoosterCharUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    realm?: StringFieldUpdateOperationsInput | string
    class?: NullableStringFieldUpdateOperationsInput | string | null
    spec?: NullableStringFieldUpdateOperationsInput | string | null
    rioScore?: NullableFloatFieldUpdateOperationsInput | number | null
    progress?: NullableStringFieldUpdateOperationsInput | string | null
    itemLevel?: NullableIntFieldUpdateOperationsInput | number | null
    wclUrl?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SignupUpdateWithoutUserInput = {
    type?: EnumSignupTypeFieldUpdateOperationsInput | $Enums.SignupType
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    saved?: BoolFieldUpdateOperationsInput | boolean
    note?: NullableStringFieldUpdateOperationsInput | string | null
    class?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSignupStatusFieldUpdateOperationsInput | $Enums.SignupStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    raid?: RaidUpdateOneRequiredWithoutSignupsNestedInput
    char?: BoosterCharUpdateOneWithoutSignupsNestedInput
  }

  export type SignupUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    raidId?: IntFieldUpdateOperationsInput | number
    type?: EnumSignupTypeFieldUpdateOperationsInput | $Enums.SignupType
    charId?: NullableIntFieldUpdateOperationsInput | number | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    saved?: BoolFieldUpdateOperationsInput | boolean
    note?: NullableStringFieldUpdateOperationsInput | string | null
    class?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSignupStatusFieldUpdateOperationsInput | $Enums.SignupStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SignupUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    raidId?: IntFieldUpdateOperationsInput | number
    type?: EnumSignupTypeFieldUpdateOperationsInput | $Enums.SignupType
    charId?: NullableIntFieldUpdateOperationsInput | number | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    saved?: BoolFieldUpdateOperationsInput | boolean
    note?: NullableStringFieldUpdateOperationsInput | string | null
    class?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSignupStatusFieldUpdateOperationsInput | $Enums.SignupStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SignupCreateManyRaidInput = {
    id?: number
    userId?: string | null
    type: $Enums.SignupType
    charId?: number | null
    displayName?: string | null
    saved?: boolean
    note?: string | null
    class?: string | null
    status?: $Enums.SignupStatus
    createdAt?: Date | string
  }

  export type SignupUpdateWithoutRaidInput = {
    type?: EnumSignupTypeFieldUpdateOperationsInput | $Enums.SignupType
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    saved?: BoolFieldUpdateOperationsInput | boolean
    note?: NullableStringFieldUpdateOperationsInput | string | null
    class?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSignupStatusFieldUpdateOperationsInput | $Enums.SignupStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    char?: BoosterCharUpdateOneWithoutSignupsNestedInput
    user?: UserUpdateOneWithoutSignupsNestedInput
  }

  export type SignupUncheckedUpdateWithoutRaidInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumSignupTypeFieldUpdateOperationsInput | $Enums.SignupType
    charId?: NullableIntFieldUpdateOperationsInput | number | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    saved?: BoolFieldUpdateOperationsInput | boolean
    note?: NullableStringFieldUpdateOperationsInput | string | null
    class?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSignupStatusFieldUpdateOperationsInput | $Enums.SignupStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SignupUncheckedUpdateManyWithoutRaidInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumSignupTypeFieldUpdateOperationsInput | $Enums.SignupType
    charId?: NullableIntFieldUpdateOperationsInput | number | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    saved?: BoolFieldUpdateOperationsInput | boolean
    note?: NullableStringFieldUpdateOperationsInput | string | null
    class?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSignupStatusFieldUpdateOperationsInput | $Enums.SignupStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RaidCreateManyPresetInput = {
    id?: number
    title: string
    difficulty: string
    lootType: string
    date: Date | string
    lead?: string | null
    bosses: number
    tanks?: number
    healers?: number
    dps?: number
    lootbuddies?: number
    channelId?: string | null
    messageId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RaidUpdateWithoutPresetInput = {
    title?: StringFieldUpdateOperationsInput | string
    difficulty?: StringFieldUpdateOperationsInput | string
    lootType?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    lead?: NullableStringFieldUpdateOperationsInput | string | null
    bosses?: IntFieldUpdateOperationsInput | number
    tanks?: IntFieldUpdateOperationsInput | number
    healers?: IntFieldUpdateOperationsInput | number
    dps?: IntFieldUpdateOperationsInput | number
    lootbuddies?: IntFieldUpdateOperationsInput | number
    channelId?: NullableStringFieldUpdateOperationsInput | string | null
    messageId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    signups?: SignupUpdateManyWithoutRaidNestedInput
  }

  export type RaidUncheckedUpdateWithoutPresetInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    difficulty?: StringFieldUpdateOperationsInput | string
    lootType?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    lead?: NullableStringFieldUpdateOperationsInput | string | null
    bosses?: IntFieldUpdateOperationsInput | number
    tanks?: IntFieldUpdateOperationsInput | number
    healers?: IntFieldUpdateOperationsInput | number
    dps?: IntFieldUpdateOperationsInput | number
    lootbuddies?: IntFieldUpdateOperationsInput | number
    channelId?: NullableStringFieldUpdateOperationsInput | string | null
    messageId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    signups?: SignupUncheckedUpdateManyWithoutRaidNestedInput
  }

  export type RaidUncheckedUpdateManyWithoutPresetInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    difficulty?: StringFieldUpdateOperationsInput | string
    lootType?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    lead?: NullableStringFieldUpdateOperationsInput | string | null
    bosses?: IntFieldUpdateOperationsInput | number
    tanks?: IntFieldUpdateOperationsInput | number
    healers?: IntFieldUpdateOperationsInput | number
    dps?: IntFieldUpdateOperationsInput | number
    lootbuddies?: IntFieldUpdateOperationsInput | number
    channelId?: NullableStringFieldUpdateOperationsInput | string | null
    messageId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SignupCreateManyCharInput = {
    id?: number
    raidId: number
    userId?: string | null
    type: $Enums.SignupType
    displayName?: string | null
    saved?: boolean
    note?: string | null
    class?: string | null
    status?: $Enums.SignupStatus
    createdAt?: Date | string
  }

  export type SignupUpdateWithoutCharInput = {
    type?: EnumSignupTypeFieldUpdateOperationsInput | $Enums.SignupType
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    saved?: BoolFieldUpdateOperationsInput | boolean
    note?: NullableStringFieldUpdateOperationsInput | string | null
    class?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSignupStatusFieldUpdateOperationsInput | $Enums.SignupStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    raid?: RaidUpdateOneRequiredWithoutSignupsNestedInput
    user?: UserUpdateOneWithoutSignupsNestedInput
  }

  export type SignupUncheckedUpdateWithoutCharInput = {
    id?: IntFieldUpdateOperationsInput | number
    raidId?: IntFieldUpdateOperationsInput | number
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumSignupTypeFieldUpdateOperationsInput | $Enums.SignupType
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    saved?: BoolFieldUpdateOperationsInput | boolean
    note?: NullableStringFieldUpdateOperationsInput | string | null
    class?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSignupStatusFieldUpdateOperationsInput | $Enums.SignupStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SignupUncheckedUpdateManyWithoutCharInput = {
    id?: IntFieldUpdateOperationsInput | number
    raidId?: IntFieldUpdateOperationsInput | number
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumSignupTypeFieldUpdateOperationsInput | $Enums.SignupType
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    saved?: BoolFieldUpdateOperationsInput | boolean
    note?: NullableStringFieldUpdateOperationsInput | string | null
    class?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSignupStatusFieldUpdateOperationsInput | $Enums.SignupStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}